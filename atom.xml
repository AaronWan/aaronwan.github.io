<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Share</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-03T10:12:16.071Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>万松</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Zen of Python, by Tim Peters</title>
    <link href="http://example.com/2022/09/03/2015-01-1-PYTHON-%E5%88%9D%E6%AC%A1%E6%8E%A5%E8%A7%A6/"/>
    <id>http://example.com/2022/09/03/2015-01-1-PYTHON-%E5%88%9D%E6%AC%A1%E6%8E%A5%E8%A7%A6/</id>
    <published>2022-09-03T10:12:16.071Z</published>
    <updated>2022-09-03T10:12:16.071Z</updated>
    
    <content type="html"><![CDATA[<p>=============</p><blockquote><p>由于自己对新知识的好奇，2014年被一位朋友吸引，当时遇到他时，他是在坚持用python进行实现自己的功能。同时用的是vim进行编写，而之前我一直是用<br>IDE<br>,2015年初，我开始了解python,首先我接触到的就是</p></blockquote><pre><code>    <figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">import this</span><br><span class="line"></span><br><span class="line">The Zen of Python</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>*<span class="strong">*Python的原则*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Beautiful is better than ugly.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*优美胜于丑陋（Python 以编写优美的代码为目标）*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Explicit is better than implicit.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Simple is better than complex.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Complex is better than complicated.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Flat is better than nested.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套） *</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Sparse is better than dense.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Readability counts.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*可读性很重要（优美的代码是可读的）*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Special cases aren&#x27;t special enough to break the rules.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Although practicality beats purity.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Errors should never pass silently.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Unless explicitly silenced.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*当存在多种可能，不要尝试去猜测*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Although that way may not be obvious at first unless you&#x27;re Dutch.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Now is better than never.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Although never is often better than *</span>right* now.</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>*<span class="strong">*做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） *</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">If the implementation is hard to explain, it&#x27;s a bad idea.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Namespaces are one honking great idea -- let&#x27;s do more of those!</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">- *</span><span class="strong">*命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">---- by Tim Peters</span></span><br><span class="line"><span class="strong"></span></span><br></pre></td></tr></table></figure></code></pre><hr><ul><li>python  也用了一段时间，感觉他和javascript很像，但是只是感觉，具体哪里像，后面我会归档一下，同时也是为自己理清思路。</li><li>她与java的区别，我目前感觉两种语言，只是语法上的不同，没有感觉到非常大的差别，我也会单独整理一份这两个语言的差别。但自己学习。</li></ul><hr>]]></content>
    
    
    <summary type="html">初次接触Python</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="语言" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>POI设置表格自动换行</title>
    <link href="http://example.com/2020/09/28/POI%E8%AE%BE%E7%BD%AE%E8%A1%A8%E6%A0%BC%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C/"/>
    <id>http://example.com/2020/09/28/POI%E8%AE%BE%E7%BD%AE%E8%A1%A8%E6%A0%BC%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C/</id>
    <published>2020-09-27T16:25:35.000Z</published>
    <updated>2022-09-03T10:12:16.078Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在开发过程中有些同学遇到需要表格自动换行,其实poi不设置高度,设置WrapText即可</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">`        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>代码片断参考</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xssfWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Workbook finalWb = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line">    XSSFSheet sheet = (XSSFSheet) finalWb.createSheet(System.currentTimeMillis()+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    sheet.setDefaultColumnWidth(<span class="number">20</span>);</span><br><span class="line">    SheetContent content=<span class="keyword">new</span> SheetContent();</span><br><span class="line">    content.setHeaders(Lists.newArrayList(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;content&quot;</span>));</span><br><span class="line">    Map&lt;String, Object&gt; temp = Maps.newHashMap();</span><br><span class="line">    temp.put(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;jdk8之前为空判断使业务代码读起来比较费劲,对整体业务逻辑的理解增加困惑;&quot;</span> + <span class="string">&quot;jdk8支持了 Optional 之后 ,使用我们可以非常轻松的将原本一大块的判断代码块变成一句话;&quot;</span>);</span><br><span class="line">    temp.put(<span class="string">&quot;content&quot;</span>,<span class="string">&quot;左侧是自动换行&quot;</span>);</span><br><span class="line">    Map&lt;String, Object&gt; temp2 = Maps.newHashMap();</span><br><span class="line">    temp2.put(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;POIFSFileSystem fs = new POIFSFileSystem(new FileInputStream(filePath));&quot;</span>);</span><br><span class="line">    temp2.put(<span class="string">&quot;content&quot;</span>,<span class="string">&quot;左侧是自动换行&quot;</span>);</span><br><span class="line">    content.setValues(Lists.newArrayList(temp,temp2));</span><br><span class="line">    writeSheet(sheet,content);</span><br><span class="line">    FileOutputStream bos=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;异常数据.xlsx&quot;</span>);</span><br><span class="line">    finalWb.write(bos);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSheet</span><span class="params">(XSSFSheet sheet, SheetContent content)</span> </span>&#123;</span><br><span class="line">    Set&lt;Object&gt; last= Sets.newHashSet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; content.getHeaders().size(); i++) &#123;</span><br><span class="line">        writeCell(sheet,<span class="number">0</span>,i,<span class="keyword">null</span>,content.getHeaders().get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> row=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; content.getValues().size(); i++) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; contents=content.getValues().get(i);</span><br><span class="line">        ArrayList&lt;Object&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;(contents.values());</span><br><span class="line">        last.add((temp.get(<span class="number">0</span>)));</span><br><span class="line">        row++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; temp.size(); i1++) &#123;</span><br><span class="line">            Object item=temp.get(i1);</span><br><span class="line">            <span class="keyword">if</span>(item <span class="keyword">instanceof</span> Double)&#123;</span><br><span class="line">                <span class="keyword">if</span>(((Double) item).intValue()==((Double) item).doubleValue())&#123;</span><br><span class="line">                    item=((Double) item).intValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            writeCell(sheet,row,i1,<span class="keyword">null</span>,item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(last.size()+<span class="string">&quot;,&quot;</span>+last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeCell</span><span class="params">(XSSFSheet sheet, <span class="keyword">int</span> r, <span class="keyword">int</span> l, Color color, Object value)</span> </span>&#123;</span><br><span class="line">    XSSFRow row = sheet.getRow(r);</span><br><span class="line">    <span class="keyword">if</span> (row == <span class="keyword">null</span>) &#123;</span><br><span class="line">        row = sheet.createRow(r);</span><br><span class="line">    &#125;</span><br><span class="line">    XSSFCell cell = row.getCell(l);</span><br><span class="line">    <span class="keyword">if</span> (cell == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cell = row.createCell(l);</span><br><span class="line">    &#125;</span><br><span class="line">    cell.setCellValue(value.toString());</span><br><span class="line">    XSSFCellStyle style = sheet.getWorkbook().createCellStyle();</span><br><span class="line">    <span class="keyword">if</span> (color == <span class="keyword">null</span>) &#123;</span><br><span class="line">        color = <span class="keyword">new</span> java.awt.Color(<span class="number">162</span>, <span class="number">187</span>, <span class="number">185</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    style.setFillForegroundColor(<span class="keyword">new</span> XSSFColor(color));</span><br><span class="line">    style.setVerticalAlignment(VerticalAlignment.TOP);</span><br><span class="line">    style.setFillPattern(CellStyle.SOLID_FOREGROUND);</span><br><span class="line">    style.setWrapText(<span class="keyword">true</span>);</span><br><span class="line">    cell.setCellStyle(style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SheetContent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String sheetName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; headers= Lists.newArrayList();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Map&lt;String,Object&gt;&gt; values=Lists.newArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addValue</span><span class="params">(List&lt;Object&gt; cells)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; value=Maps.newLinkedHashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headers.size(); i++) &#123;</span><br><span class="line">            value.put(headers.get(i)+<span class="string">&quot;&quot;</span>,cells.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        values.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在开发过程中有些同学遇到需要表格自动换行,其实poi不设置高度,设置WrapText即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pr</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="jdk8.java" scheme="http://example.com/tags/jdk8-java/"/>
    
    <category term="poi" scheme="http://example.com/tags/poi/"/>
    
  </entry>
  
  <entry>
    <title>jdk_null有关判断--Optional</title>
    <link href="http://example.com/2020/09/23/jdk-null%E6%9C%89%E5%85%B3%E5%88%A4%E6%96%AD/"/>
    <id>http://example.com/2020/09/23/jdk-null%E6%9C%89%E5%85%B3%E5%88%A4%E6%96%AD/</id>
    <published>2020-09-23T13:56:13.000Z</published>
    <updated>2022-09-03T10:12:16.078Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jdk8之前为空判断使业务代码读起来比较费劲,对整体业务逻辑的理解增加困惑;<br>jdk8支持了 Optional 之后 ,使用我们可以非常轻松的将原本一大块的判断代码块变成一句话;</p></blockquote><h3 id="正常的判空优化效果"><a href="#正常的判空优化效果" class="headerlink" title="正常的判空优化效果"></a>正常的判空优化效果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(<span class="keyword">null</span>).orElse(<span class="string">&quot;default&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="从对象中取值时"><a href="#从对象中取值时" class="headerlink" title="从对象中取值时"></a>从对象中取值时</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String userName=<span class="keyword">null</span>;</span><br><span class="line">User user=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">  userName=<span class="string">&quot;username is null&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  userName=user.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">优化后</span><br><span class="line"></span><br><span class="line">userName=Optional.ofNullable(user).map((temp)-&gt;temp.getName()).orElse(<span class="string">&quot;default&quot;</span>);</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">userName=Optional.ofNullable(user).flatMap(user1 -&gt; Optional.ofNullable(user1.getName())).orElse(<span class="string">&quot;happy&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;jdk8之前为空判断使业务代码读起来比较费劲,对整体业务逻辑的理解增加困惑;&lt;br&gt;jdk8支持了 Optional 之后 ,使用我们可以非常轻松的将原本一大块的判断代码块变成一句话;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;正常的判空</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="jdk8.java" scheme="http://example.com/tags/jdk8-java/"/>
    
    <category term="jdk" scheme="http://example.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>Alfred Workflow快速打开idea项目</title>
    <link href="http://example.com/2020/09/20/alfred%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80idea%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2020/09/20/alfred%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80idea%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-09-20T14:19:49.000Z</published>
    <updated>2022-09-03T10:12:16.078Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/alfred/open_idea.gif"></p><ol><li>Mac 安装Alfred</li><li>进行workflow的设置</li></ol><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">keyword--&gt;<span class="keyword">file</span> <span class="built_in">filter</span>--&gt; <span class="keyword">open</span> <span class="keyword">file</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/alfred/open_idea.gif&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mac 安装Alfred&lt;/li&gt;
&lt;li&gt;进行workflow的设置&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="日常工具" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://example.com/tags/mac/"/>
    
    <category term="alfred" scheme="http://example.com/tags/alfred/"/>
    
    <category term="workflow" scheme="http://example.com/tags/workflow/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://example.com/2018/04/15/redis/"/>
    <id>http://example.com/2018/04/15/redis/</id>
    <published>2018-04-15T01:23:48.000Z</published>
    <updated>2022-09-03T10:12:16.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-redis-实现原理"><a href="#一-redis-实现原理" class="headerlink" title="一. redis 实现原理"></a>一. redis 实现原理</h2><h3 id="五种类型的键的底层实现数据结构"><a href="#五种类型的键的底层实现数据结构" class="headerlink" title="五种类型的键的底层实现数据结构"></a>五种类型的键的底层实现数据结构</h3><p>具体命令可参考<a href="2015/11/10/redis%E7%B4%A2%E5%BC%95/">命令</a></p><ol><li><p>SDS( simple dynamic string) 简单动态字符串</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>链表</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">listNode *head;</span><br><span class="line">listNode *tail;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"><span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"><span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"><span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字典</p><p> Redis 的字典使用哈希表作为底层实现,一个哈希敷衍里面可以有多个节点,每个节点就保存了字典中的一个键值对;</p><p> 新添加一个键值对到字典里时,程序需要先根据键值对的键计算出哈希值和索引值,然后根据索引值,将包含新键值对的哈希表节点放到哈希表数组的指定索引上面.当有两个或以上数量的键被分配到哈希数组的同一个索引上面时,我们称为冲突.这里使用链地址法解决键冲突.</p><ul><li><p>哈希表</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">dictEntry **table;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  sizemask 值和哈希值一起决定一个键应该被放到table数组的哪个索引上面.</p></li><li><p>哈希表节点</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line"><span class="keyword">void</span> *key;</span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line"><span class="keyword">void</span> *val;</span><br><span class="line">uint64_tu64;</span><br><span class="line">int64_ts64;</span><br><span class="line">&#125; v;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">//解决键冲突的问题</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure></li><li><p>字典</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">dictType *type; <span class="comment">//类型特定函数</span></span><br><span class="line"><span class="keyword">void</span> *privdata;<span class="comment">//私有数据</span></span><br><span class="line">dictht ht[<span class="number">2</span>];<span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">int</span> trehashidx;<span class="comment">//索引</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></li><li><p>rehash(实际过程,是渐进式的)</p><p>  当哈希表中键值的数量太多或太少时,为了让哈希表的负载因子维持在一个合理的范围之内,程序需要对哈希表的大小进行相应的扩展或者收缩.</p><ol><li><p>为字段的ht[1]哈希表分配空间,这个空间大小取决于要执行的操作,以及ht[0]当前包含的键值对数量</p><ol><li>如果是扩展操作,那么大小为第一个大于等于ht[0].used*2的2的n次方</li><li>如果执行的是收缩操作,那么ht[1]的大小为第一个大于等于ht[0].used的2的n次方</li></ol></li><li><p>将保存在ht[0]中的所有键值对rehash到ht[1]上面:rehash指重新计算键的哈希值和索引值,然后将键值对放置到ht[1]哈希表的指定位置上</p></li><li><p>将ht[0]释放空间,同时将ht[0]和ht[1]换位置</p><p>何时进行扩展和收缩<br>负载因子= ht[0].used(已保存的节点数量)/哈希表的大小</p><p>当负载因子大于 5 (待确认),或&lt;0.1 时</p></li></ol></li></ul></li><li><p><a href="http://daoluan.net/%E6%9C%AA%E5%88%86%E7%B1%BB/2014/06/26/decode-redis-data-struct-skiplist.html">跳跃表</a></p><p> skiplist 是一种有序的数据结构,它通过在每个节点中维持多个指向其他节点的指针,从而达到快速访问节点的目的.<br> redis在以下两个地方用到了跳跃表:</p><ol><li>有序集合键 zset</li><li>在集群节点中用途内部数据结构</li></ol></li><li><p>整数集合</p><p> intset 是集合键的底层实现之一,当一个集合只包含整数值元素,并且这个集合的元素数量不多时,Redis就会使用整数集合作为集合键的底层实现.</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD numbers 1 3 5 6 7</span><br><span class="line">(integer) 5</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;intset&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd numbers 0943890384093845903845094385</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; smembers numbers</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;0943890384093845903845094385&quot;</span><br><span class="line">3) &quot;7&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;6&quot;</span><br><span class="line">6) &quot;1&quot;</span><br><span class="line">7) &quot;9&quot;</span><br><span class="line">8) &quot;5&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="每当我们要将一个新元素添加到整数集合里面-并且新元素的类型比整数集合现有的所有元素的类型都要长时-整数集合需要先进行升级-然后才能将新元素添加到整数集合里面-请记住-这里不会降级的"><a href="#每当我们要将一个新元素添加到整数集合里面-并且新元素的类型比整数集合现有的所有元素的类型都要长时-整数集合需要先进行升级-然后才能将新元素添加到整数集合里面-请记住-这里不会降级的" class="headerlink" title=" 每当我们要将一个新元素添加到整数集合里面,并且新元素的类型比整数集合现有的所有元素的类型都要长时,整数集合需要先进行升级,然后才能将新元素添加到整数集合里面,请记住,这里不会降级的"></a> 每当我们要将一个新元素添加到整数集合里面,并且新元素的类型比整数集合现有的所有元素的类型都要长时,整数集合需要先进行升级,然后才能将新元素添加到整数集合里面,请记住,这里不会降级的</h2><p> 其是Redis保存整数值的集合抽象数据结构,它可以保存int16_t,int32_t,int64_t的整数值,并且保证集合中不会出现重复元素.</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> encoding;<span class="comment">//编码方式 INTSET_ENC_INT16,INTSET_ENC_INT32,INTSET_ENC_INT64</span></span><br><span class="line"><span class="keyword">uint32_t</span> length;<span class="comment">//集合包含的元素数量</span></span><br><span class="line"><span class="keyword">int8_t</span> contents[]; <span class="comment">//保存元素的数组,数组中按值的大小从小到大有序排列,并且数组中不包含任何重复项;其真正的类型取决于encoding属性的值:</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>压缩列表<br> ziplist,是列表键和哈希键的底层实现之一.当一个列表键只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做列表键的底层实现.</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush kdf djf f df d f d f &quot;sdf&quot;</span><br><span class="line">(integer) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING kdf</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure><p> 压缩列表是为了节约内存而开发的,是由一系列特殊的连续内存块组成的顺序型数据结构.一个压缩列表可以包含任意多个节点,每个节点可以保存一个字节数组或者一个整数值.</p></li></ol><h3 id="对象处理机制以及数据库的实现原理"><a href="#对象处理机制以及数据库的实现原理" class="headerlink" title="对象处理机制以及数据库的实现原理"></a>对象处理机制以及数据库的实现原理</h3><ol><li><p>导入</p><ol><li>Redis 基于这些数据结构创建一个对象系统,其包含 字符串,列表对象,哈希对象,集合对象和有序集合对象 五种类型的对象,每种对象都至少一种我们前面所介绍的数据结构.</li><li>使用对象的好处,我们可以针对不同的使用场景,为对象设置多种不同的数据结构pugmww而优化对象在不同场景下的使用效率.</li><li>对象系统基于引用计数技术的内存回收机制,当程序不再使用某个对象的时候,这个对象所战胜的内存就会被自动释放;另外,Redis还通过引用计数技术实现了对象共享机制,这一机制可以在适当的条件下,通过让多个数据库键共享同一个对象来节约内存.</li><li>对象带有访问时间记录信息,该信息可以用于计算数据库的空转时长 ,在服务器启用了maxmemory功能的情况下,空转时长较大的那些键可能会优先被服务器删除.</li></ol></li><li><p>对象的类型和编码 type</p><p> Redis使用对象来表示数据库中的键值,每次我们在库中新创建一个键值对时,我们至少会创建两个对象,一个是键对象,另一个是值对象.</p> <figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6379</span>&gt; set name aaron</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;aaron&quot;</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; OBJECT ENCODING name</span><br><span class="line"><span class="string">&quot;embstr&quot;</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; type name</span><br><span class="line">string</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; OBJECT idletime name</span><br><span class="line">(integer) <span class="number">46</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p> 每一个对象都由一个redisObject结构表示,该结构中和保存数据有关的三个属性分别是type属性,encoding属性和ptr属性:</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"><span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"><span class="keyword">void</span> *ptr;<span class="comment">//每日向底层实现数据结构的指针</span></span><br><span class="line"><span class="keyword">int</span> refcount;<span class="comment">//引用计数</span></span><br><span class="line"><span class="keyword">unsigned</span> lru:<span class="number">22</span>;<span class="comment">//该对象最后一次被访问的时间</span></span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure><p> type记录了对象的类型,这个属性的值有 string,list,hash,set,zset</p></li><li><p>编码和底层实现  OBJECT ENCODING<br> 对象的ptr指针指向对象的底层实现数据结构,而这些数据结构由对象的encoding属性决定.也就是说这个对象使用了什么数据结构作为对象的底层实现,这个属性值可以是</p> <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">int (<span class="name">long</span> 类型)</span><br><span class="line">embstr (<span class="name">embstr</span>编码的简单动态字符串)</span><br><span class="line">raw (简单动态字符串)</span><br><span class="line">ht (字典)</span><br><span class="line">linkedlist (双端链表)</span><br><span class="line">ziplist (压缩链表)</span><br><span class="line">intset (整数集合)</span><br><span class="line">skiplist (跳跃链表和字典)</span><br></pre></td></tr></table></figure><p> 每种类型对象都至少使用了两种不同的编码.</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">string int/embstr/raw</span><br><span class="line">list ziplist/linkedlist</span><br><span class="line">hash ziplist/ht</span><br><span class="line"><span class="builtin-name">set</span>  intset/ht</span><br><span class="line">zset  ziplist/skiplist</span><br></pre></td></tr></table></figure></li><li><p>数据共享 只共享0-9999的字符串对象</p> <figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET a <span class="number">100</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; OBJECT <span class="built_in">ref</span>count a</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; OBJECT <span class="built_in">ref</span>count a</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET b <span class="number">100</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; OBJECT <span class="built_in">ref</span>count a</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="单机数据库的实现"><a href="#单机数据库的实现" class="headerlink" title="单机数据库的实现"></a>单机数据库的实现</h3><ol><li><p>在redisServer结构的db数组中,每个redisDb 结构代表一个数据库,启动服务器时,服务器会根据dbnum来决定应该创建多少个数据库:</p> <figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line"><span class="meta">...</span></span><br><span class="line">redisDb *db;</span><br><span class="line">int dbnum;</span><br><span class="line"><span class="meta">...</span></span><br><span class="line">&#125;redisClient</span><br></pre></td></tr></table></figure><p> 客户端可以根据命令select来进行切换目标数据库</p></li><li><p>数据库键空间</p><p> 是一个键值对数据库服务器,其中每个数据库都由一个redisDb结构表示,其中redisDb结构的dict字典保存了数据库中的所有键值对,我们称这个字典为 键空间<br> typedef struct redisDb{<br> dict *dict;<br> dict *expires;  key 是对象,value 是过期时间<br> }redisDb</p></li><li><p>设置生存时间或过期时间</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name wansong</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire name 10</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;wansong&quot;</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>数据库通知<br> 2.8 新版本中增加的功能,可以通过订阅给它的频道或者模式,来获知数据库中键的变化.及数据库中命令的执行情况.</p></li></ol><h3 id="RDB-持久化和-AOF-持久化的实现原理"><a href="#RDB-持久化和-AOF-持久化的实现原理" class="headerlink" title="RDB 持久化和 AOF 持久化的实现原理"></a>RDB 持久化和 AOF 持久化的实现原理</h3><p>RDB持久化功能,可以将Redis在内存中的数据库状态保存到磁盘里面,避免数据意外丢失.也可以根据服务器配置选项定期执行.<br>该功能可以将某个时间点上的数据库状态保存到一个RDB文件中.该文件是一个经过压缩的二进制文件,通过该文件可以还原生成RDB文件时的数据库状态.</p><ol><li><p>RDB文件的创建与载入</p><p> save 命令会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器进程阻塞期间,服务器不处理任务命令请求.</p><p> bgsave background saving started 该命令会派生出一个子进程,然后由子进程负责创建RDB文件,服务器进程继续处理命令请求</p><p> 创建文件的实际工作由rdbSave函数完成,save和bgsave命令会以不同的方式调用这个函数.</p><p> RDB文件的载入是自动的,当程序启动时会自动载入,另外注意AOF文件的更新频率通常比RDB高,所以:</p><ol><li><p>如果服务器开启了AOF持久化功能,那么服务器会优先使用AOF文件还原数据库状态</p></li><li><p>只有在AOF持久化功能处于关闭状态时,服务器才会使用RDB文件来还原数据库状态.</p><p>载入RDB文件的实际工作由rdbLoad函数完成;文件载入时服务器处于阻塞状态.</p></li></ol></li><li><p>自动间隔性保存</p><p>可以通过save选项设置多个保存条件,但只要其中任意一个条件被满足,服务器就会执行bgsave.</p><p>save 900 1  服务器900秒之内,对数据库进行至少一次修改,就进行bgsave</p></li></ol><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="Redis-基于-Reactor模式开发的网络事件处理器-称作-文件事件处理器-File-Event-Handler"><a href="#Redis-基于-Reactor模式开发的网络事件处理器-称作-文件事件处理器-File-Event-Handler" class="headerlink" title="Redis 基于 Reactor模式开发的网络事件处理器,称作 文件事件处理器 (File Event Handler)"></a>Redis 基于 Reactor模式开发的网络事件处理器,称作 文件事件处理器 (File Event Handler)</h4><ol><li>使用I/O多路复用程序来同时监听多个套接字,并根据目前执行的任务来为套接字关联不同的事件</li><li>当被监听的套接字准备好执行连接应答,读取,写入,关闭 等操作时,与其对应的文件事件就会产生,这时1中注册好的事件处理器就来进行处理这些事件</li></ol><h4 id="时间事件-id-when-handlers"><a href="#时间事件-id-when-handlers" class="headerlink" title="时间事件 id/when/handlers"></a>时间事件 id/when/handlers</h4><ol><li>定时事件</li><li>周期性事件</li></ol><h3 id="事务实现原理-ACID"><a href="#事务实现原理-ACID" class="headerlink" title="事务实现原理 ACID"></a>事务实现原理 ACID</h3><h3 id="ServerCron函数"><a href="#ServerCron函数" class="headerlink" title="ServerCron函数"></a>ServerCron函数</h3><blockquote><blockquote><p>服务器 默认每100毫秒执行一次</p></blockquote></blockquote><ol><li>更新服务器时间缓存</li><li>更新LRU时钟(如 Redis对象都会有一个LRU属性,这个属性保存了对象最后一次被命令访问的时间)</li><li>更新服务器每秒执行命令的次数(INFO status)</li><li>更新服务器内存峰值记录</li><li>处理SIGTERM信号 每次运行时,程序会对服务器状态的shutdown_asap属性进行检查,看是否要关闭服务器</li><li>管理客户端资源: 已超时 或 是否清理输出缓冲区</li><li>管理数据库资源: 删除过期键,并在需要时 对字典进行收缩操作</li><li>检查持久化操作的运行状态</li><li>将AOF缓冲区的内容写入到AOF文件</li><li>关闭异步客户端</li><li>增加cronloops计数器的值</li></ol><h3 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h3><p>初始化服务器状态结构,载入配置选项,还原数据库状态,执行事件循环</p><h3 id="订阅与发布实现原理"><a href="#订阅与发布实现原理" class="headerlink" title="订阅与发布实现原理"></a>订阅与发布实现原理</h3><h3 id="Lua-脚本功能的实现原理。"><a href="#Lua-脚本功能的实现原理。" class="headerlink" title="Lua 脚本功能的实现原理。"></a>Lua 脚本功能的实现原理。</h3><h3 id="SORT-命令的实现原理。"><a href="#SORT-命令的实现原理。" class="headerlink" title="SORT 命令的实现原理。"></a>SORT 命令的实现原理。</h3><h3 id="慢查询日志的实现原理。-打开慢查询-查看日期-SLOWLOG-GET"><a href="#慢查询日志的实现原理。-打开慢查询-查看日期-SLOWLOG-GET" class="headerlink" title="慢查询日志的实现原理。 打开慢查询,查看日期 SLOWLOG GET"></a>慢查询日志的实现原理。 打开慢查询,查看日期 SLOWLOG GET</h3><h3 id="高并发如何做到"><a href="#高并发如何做到" class="headerlink" title="高并发如何做到"></a>高并发如何做到</h3><pre><code>虽是单线程单进行,但 使用I/O多路复用(select/epoll,evport,kqueue)程序来同时监听多个套接字 的方式来处理命令请求,并与多个客户端进行通信.</code></pre><h2 id="二-redis-主要关注点"><a href="#二-redis-主要关注点" class="headerlink" title="二. redis 主要关注点"></a>二. redis 主要关注点</h2><h3 id="redis-为什么是单线程"><a href="#redis-为什么是单线程" class="headerlink" title="redis 为什么是单线程"></a><a href="https://blog.csdn.net/qqqqq1993qqqqq/article/details/77538202">redis 为什么是单线程</a></h3><h3 id="redis-过期索引是如何做到的"><a href="#redis-过期索引是如何做到的" class="headerlink" title="redis 过期索引是如何做到的"></a>redis 过期索引是如何做到的</h3><ol><li><p>redis 的存储结构</p></li><li><p>删除策略</p> <figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>定时删除:在设置键的过期时间的同时,创建一个定时器,让定时器在键的过期时间来临时,立即对键执行删除操作(对内存友好,最及时)</span><br><span class="line"><span class="bullet">* </span>定期删除:每一段时间,进行数据库过期索引的扫瞄,将已经过期的键 进行删除; 至于删除多少过期键和检查哪些数据库,都由算法决定</span><br><span class="line"><span class="bullet">* </span>惰性删除: 每次取键时,校验一下是否过期,若已经过期 就进行删除</span><br><span class="line"></span><br><span class="line">其实最终使用的是 定期和惰性 两个策略 配合实现</span><br></pre></td></tr></table></figure><h3 id="redis-服务器配置"><a href="#redis-服务器配置" class="headerlink" title="redis 服务器配置"></a><a href="https://www.cnblogs.com/joshua317/p/5635297.html">redis 服务器配置</a></h3><h3 id="redis-有哪些功能"><a href="#redis-有哪些功能" class="headerlink" title="redis 有哪些功能"></a><a href="">redis 有哪些功能</a></h3><h3 id="redis-如何Failover"><a href="#redis-如何Failover" class="headerlink" title="redis 如何Failover()"></a>redis 如何Failover()</h3> <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">哨兵（Sentinel）和复制（<span class="keyword">Replication</span>）</span><br><span class="line">Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能；<span class="keyword">Replication</span>则是负责让一个Redis服务器可以配备多个备份的服务器</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="redis-目前流程的实施架构有哪些"><a href="#redis-目前流程的实施架构有哪些" class="headerlink" title="redis 目前流程的实施架构有哪些"></a>redis 目前流程的实施架构有哪些</h3><ol><li>哨兵Sentinel,复制（replication）</li><li>集群（cluster）</li></ol><h2 id="三-redis-应用场景"><a href="#三-redis-应用场景" class="headerlink" title="三. redis 应用场景"></a>三. <a href="https://www.cnblogs.com/NiceCui/p/7794659.html">redis 应用场景</a></h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://item.jd.com/11486101.html">Redis设计与实现</a></li></ol>]]></content>
    
    
    <summary type="html">Java redis</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>微服务相关概念</title>
    <link href="http://example.com/2018/04/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2018/04/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2018-04-14T00:53:22.000Z</published>
    <updated>2022-09-03T10:12:16.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务治理基本概念"><a href="#服务治理基本概念" class="headerlink" title="服务治理基本概念"></a>服务治理基本概念</h2><ol><li>服务的伸缩控制</li><li>身份验证与授权 *</li><li>服务注册与发现 *</li><li>反向代理与负载均衡</li><li>路由控制 *</li><li>流量切换 *</li><li>日志管理 *</li><li>性能度量、监控与调优 *</li><li>分布式跟踪 *</li><li>过载保护 *</li><li>服务降级 *</li><li>服务部署与版本升级策略支持 *</li><li>错误处理 *</li><li>国际化</li></ol><h3 id="服务的伸缩控制"><a href="#服务的伸缩控制" class="headerlink" title="服务的伸缩控制"></a>服务的伸缩控制</h3><h3 id="身份验证与授权"><a href="#身份验证与授权" class="headerlink" title="身份验证与授权"></a>身份验证与授权</h3><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><ol><li>dubbo zookeeper</li></ol><h3 id="反向代理与负载均衡"><a href="#反向代理与负载均衡" class="headerlink" title="反向代理与负载均衡"></a>反向代理与负载均衡</h3><ol><li>vertx</li><li>nginx</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;服务治理基本概念&quot;&gt;&lt;a href=&quot;#服务治理基本概念&quot; class=&quot;headerlink&quot; title=&quot;服务治理基本概念&quot;&gt;&lt;/a&gt;服务治理基本概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;服务的伸缩控制&lt;/li&gt;
&lt;li&gt;身份验证与授权 *&lt;/li&gt;
&lt;li&gt;服务注册</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="服务治理" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="CAP" scheme="http://example.com/tags/CAP/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://example.com/2018/03/29/%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2018/03/29/%E6%8E%92%E5%BA%8F/</id>
    <published>2018-03-29T00:04:24.000Z</published>
    <updated>2022-09-03T10:12:16.078Z</updated>
    
    
    <summary type="html">如:各种排序实现</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>二分法查找及扩展</title>
    <link href="http://example.com/2018/03/29/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E5%8F%8A%E6%89%A9%E5%B1%95/"/>
    <id>http://example.com/2018/03/29/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E5%8F%8A%E6%89%A9%E5%B1%95/</id>
    <published>2018-03-28T23:59:02.000Z</published>
    <updated>2022-09-03T10:12:16.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h2><blockquote><blockquote><p>给一个有序数组,查找出k所在位置</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aaron</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 6.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheFirstLessThan100</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> middleValue = array[middle];</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (middleValue &lt; value) &#123;</span><br><span class="line">                low = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middleValue &gt; value) &#123;</span><br><span class="line">                high = middle - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;times:%d,index:%d,value:%d\n&quot;</span>, count, middle, value);</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = find(array, array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查出第一个大于N的位置"><a href="#查出第一个大于N的位置" class="headerlink" title="查出第一个大于N的位置"></a>查出第一个大于N的位置</h2><blockquote><blockquote><p>从有序的数组中,找出第一个大于N的数字的位置</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findFirstBigIndex</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lastBigIndex=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> middleValue = array[middle];</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (middleValue &lt;= value) &#123;</span><br><span class="line">                low = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middleValue &gt; value) &#123;</span><br><span class="line">                high = middle - <span class="number">1</span>;</span><br><span class="line">                lastBigIndex=middle;</span><br><span class="line">                System.out.printf(<span class="string">&quot;times:%d,index:%d,value:%d,middle:%d\n&quot;</span>, count, middle, value,middleValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastBigIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findFirstBigIndex1</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> middleValue = array[middle];</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (middleValue &lt;= value) &#123;</span><br><span class="line">                low = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middleValue &gt; value) &#123;</span><br><span class="line">                high = middle - <span class="number">1</span>;</span><br><span class="line">                System.out.printf(<span class="string">&quot;times:%d,index:%d,value:%d,middle:%d\n&quot;</span>, count, middle, value,middleValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">34</span>,<span class="number">324</span>,<span class="number">546</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = findFirstBigIndex1(array, i);</span><br><span class="line">            <span class="keyword">int</span> index2 = findFirstBigIndex(array, i);</span><br><span class="line">            System.out.println(index+<span class="string">&quot;--&quot;</span>+index2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">如:实现二分法查找,查找第一个大于N的值</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="查找" scheme="http://example.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>微信头像九宫格算法</title>
    <link href="http://example.com/2018/03/25/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F%E4%B9%9D%E5%AE%AB%E6%A0%BC%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2018/03/25/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F%E4%B9%9D%E5%AE%AB%E6%A0%BC%E7%AE%97%E6%B3%95/</id>
    <published>2018-03-25T02:46:33.000Z</published>
    <updated>2022-09-03T10:12:16.077Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>分别计算1-9个头像在九宫格中的位置</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ImageCell&gt; <span class="title">createMergeCell</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> totalWidth)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> totalRow = (<span class="keyword">int</span>) Math.ceil(Math.sqrt(n));</span><br><span class="line">      <span class="keyword">int</span> outline = <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">int</span> width = ((totalWidth - outline) / totalRow);</span><br><span class="line">      <span class="keyword">int</span> border = width / <span class="number">20</span>;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> Lists.newArrayList(<span class="keyword">new</span> ImageCell(border, border, width - <span class="number">2</span> * border));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> lastAloneNum = n % totalRow;</span><br><span class="line">      <span class="keyword">int</span> totalFullRow = n / totalRow;</span><br><span class="line">      <span class="keyword">int</span> lastRow = totalRow - totalFullRow - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> firstStartX = (totalWidth - lastAloneNum * width) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> firstStartY = lastRow * width;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> otherSpace = (totalWidth - totalRow * width) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> yOffset = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (totalRow != totalFullRow + (lastAloneNum != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>)) &#123;</span><br><span class="line">          yOffset = -width / <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;ImageCell&gt; imageCells = Lists.newArrayList();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          <span class="keyword">int</span> x = <span class="number">0</span>, y = firstStartY;</span><br><span class="line">          <span class="keyword">if</span> (i &lt; lastAloneNum) &#123;</span><br><span class="line">              x = firstStartX + i * width;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              x = (i - lastAloneNum) % totalRow * width;</span><br><span class="line">              y = firstStartY + ((i - lastAloneNum) / totalRow + <span class="number">1</span>) * width;</span><br><span class="line">          &#125;</span><br><span class="line">          imageCells.add(<span class="keyword">new</span> ImageCell(x + border + otherSpace, y + border + otherSpace + yOffset, width - <span class="number">2</span> * border));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> imageCells;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Data</span></span><br><span class="line">  <span class="meta">@AllArgsConstructor</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageCell</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="keyword">int</span> y;</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-------------------n=1---------------------</span><br><span class="line">x:7,y:7,width:131</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------n=2---------------------</span><br><span class="line">x:6,y:42,width:66</span><br><span class="line">x:78,y:42,width:66</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------n=3---------------------</span><br><span class="line">x:45,y:6,width:66</span><br><span class="line">x:6,y:78,width:66</span><br><span class="line">x:78,y:78,width:66</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------n=4---------------------</span><br><span class="line">x:6,y:6,width:66</span><br><span class="line">x:78,y:6,width:66</span><br><span class="line">x:6,y:78,width:66</span><br><span class="line">x:78,y:78,width:66</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------n=5---------------------</span><br><span class="line">x:32,y:29,width:44</span><br><span class="line">x:80,y:29,width:44</span><br><span class="line">x:5,y:77,width:44</span><br><span class="line">x:53,y:77,width:44</span><br><span class="line">x:101,y:77,width:44</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------n=6---------------------</span><br><span class="line">x:5,y:29,width:44</span><br><span class="line">x:53,y:29,width:44</span><br><span class="line">x:101,y:29,width:44</span><br><span class="line">x:5,y:77,width:44</span><br><span class="line">x:53,y:77,width:44</span><br><span class="line">x:101,y:77,width:44</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------n=7---------------------</span><br><span class="line">x:56,y:5,width:44</span><br><span class="line">x:5,y:53,width:44</span><br><span class="line">x:53,y:53,width:44</span><br><span class="line">x:101,y:53,width:44</span><br><span class="line">x:5,y:101,width:44</span><br><span class="line">x:53,y:101,width:44</span><br><span class="line">x:101,y:101,width:44</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------n=8---------------------</span><br><span class="line">x:32,y:5,width:44</span><br><span class="line">x:80,y:5,width:44</span><br><span class="line">x:5,y:53,width:44</span><br><span class="line">x:53,y:53,width:44</span><br><span class="line">x:101,y:53,width:44</span><br><span class="line">x:5,y:101,width:44</span><br><span class="line">x:53,y:101,width:44</span><br><span class="line">x:101,y:101,width:44</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------n=9---------------------</span><br><span class="line">x:5,y:5,width:44</span><br><span class="line">x:53,y:5,width:44</span><br><span class="line">x:101,y:5,width:44</span><br><span class="line">x:5,y:53,width:44</span><br><span class="line">x:53,y:53,width:44</span><br><span class="line">x:101,y:53,width:44</span><br><span class="line">x:5,y:101,width:44</span><br><span class="line">x:53,y:101,width:44</span><br><span class="line">x:101,y:101,width:44</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">如:分别计算1-9个头像在九宫格中的位置</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>取一个数字二进制中1的个数</title>
    <link href="http://example.com/2018/03/24/%E5%8F%96%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://example.com/2018/03/24/%E5%8F%96%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2018-03-24T12:10:29.000Z</published>
    <updated>2022-09-03T10:12:16.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><ol><li><p>二进制中1的个数</p><pre><code> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (n&gt;<span class="number">0</span>)  &#123;</span><br><span class="line">        count++ ;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 复杂度: &lt; log2n</code></pre></li><li><p>方案二</p><pre><code> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of one-bits in the two&#x27;s complement binary</span></span><br><span class="line"><span class="comment"> * representation of the specified &#123;<span class="doctag">@code</span> int&#125; value.  This function is</span></span><br><span class="line"><span class="comment"> * sometimes referred to as the &lt;i&gt;population count&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i the value whose bits are to be counted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of one-bits in the two&#x27;s complement binary</span></span><br><span class="line"><span class="comment"> *     representation of the specified &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 5-2</span></span><br><span class="line">    i = i - ((i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    i = (i + (i &gt;&gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i &amp; <span class="number">0x3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 复杂度: 1</code></pre></li><li><p>方案三</p><pre><code> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countBit1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp&lt;=n)  &#123;</span><br><span class="line">        <span class="keyword">if</span>((temp&amp;n)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        temp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>给定一个数字n计算从1到n每一个数字的二进制中包含1的个数</li></ol><pre><code>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> div = i / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> mod = i % <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mod == <span class="number">1</span>) &#123;</span><br><span class="line">                ret[i] = ret[div] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ret[i] = ret[div];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><!--```flow--><!--st=>start: Start|past:>http://www.google.com[blank]--><!--e=>end: End:>http://www.google.com--><!--op1=>operation: My Operation|past--><!--op2=>operation: Stuff|current--><!--sub1=>subroutine: My Subroutine|invalid--><!--cond=>condition: Yes--><!--or No?|approved:>http://www.google.com--><!--c2=>condition: Good idea|rejected--><!--io=>inputoutput: catch something...|request--><!--st->op1(right)->cond--><!--cond(yes, right)->c2--><!--cond(no)->sub1(left)->op1--><!--c2(yes)->io->e--><!--c2(no)->op2->e--><!--```-->]]></content>
    
    
    <summary type="html">如:2---&gt;10---&gt;1,5---&gt;101---&gt;2</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java.util.concurrent概览</title>
    <link href="http://example.com/2018/03/24/java-util-concurrent%E6%A6%82%E8%A7%88/"/>
    <id>http://example.com/2018/03/24/java-util-concurrent%E6%A6%82%E8%A7%88/</id>
    <published>2018-03-24T09:51:58.000Z</published>
    <updated>2022-09-03T10:12:16.077Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>java.util.concurrent 包含许多线程安全、测试良好、高性能的并发构建块。不客气地说，创建 java.util.concurrent 的目的就是要实现 Collection 框架对数据结构所执行的并发操作。通过提供一组可靠的、高性能并发构建块，开发人员可以提高并发类的线程安全、可伸缩性、性能、可读性和可靠性。</p></blockquote></blockquote><blockquote><blockquote><p>如果一些类名看起来相似，可能是因为 java.util.concurrent 中的许多概念源自 Doug Lea 的 util.concurrent 库（请参阅 参考资料）。</p></blockquote></blockquote><h2 id="JDK-5-0-中的并发改进可以分为三组："><a href="#JDK-5-0-中的并发改进可以分为三组：" class="headerlink" title="JDK 5.0 中的并发改进可以分为三组："></a>JDK 5.0 中的并发改进可以分为三组：</h2><pre><code>1. JVM 级别更改。    大多数现代处理器对并发对某一硬件级别提供支持，通常以 compare-and-swap （CAS）指令形式。CAS 是一种低级别的、细粒度的技术，它允许多个线程更新一个内存位置，同时能够检测其他线程的冲突并进行恢复。它是许多高性能并发算法的基础。在 JDK 5.0 之前，Java 语言中用于协调线程之间的访问的惟一原语是同步，同步是更重量级和粗粒度的。公开 CAS 可以开发高度可伸缩的并发 Java 类。这些更改主要由 JDK 库类使用，而不是由开发人员使用。2. 低级实用程序类 -- 锁定和原子类。    使用 CAS 作为并发原语，ReentrantLock 类提供与 synchronized 原语相同的锁定和内存语义，然而这样可以更好地控制锁定（如计时的锁定等待、锁定轮询和可中断的锁定等待）和提供更好的可伸缩性（竞争时的高性能）。大多数开发人员将不再直接使用 ReentrantLock 类，而是使用在 ReentrantLock 类上构建的高级类。3. 高级实用程序类。    这些类实现并发构建块，每个计算机科学文本中都会讲述这些类 -- 信号、互斥、闩锁、屏障、交换程序、线程池和线程安全集合类等。大部分开发人员都可以在应用程序中用这些类，来替换许多（如果不是全部）同步、wait() 和 notify() 的使用，从而提高性能、可读性和正确性。</code></pre><h2 id="本文主要内容"><a href="#本文主要内容" class="headerlink" title="本文主要内容"></a>本文主要内容</h2><pre><code>本教程将重点介绍 java.util.concurrent 包提供的高级实用程序类 -- 线程安全集合、线程池和同步实用程序。这些是初学者和专家都可以使用的&quot;现成&quot;类。在第一小节中，我们将回顾并发的基本知识，尽管它不应取代对线程和线程安全的了解。那些一点都不熟悉线程的读者应该先参考一些关于线程的介绍，如&quot;Introduction to Java Threads&quot;教程（请参阅参考资料）。接下来的几个小节将研究 java.util.concurrent 中的高级实用程序类 -- 线程安全集合、线程池、信号和同步工具。最后一小节将介绍 java.util.concurrent 中的低级并发构建块，并提供一些性能测评来显示新 java.util.concurrent 类的可伸缩性的改进。</code></pre><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><p>什么是线程？</p><p> 所有重要的操作系统都支持进程的概念 – 独立运行的程序，在某种程度上相互隔离。</p><p> 线程有时称为 轻量级进程。与进程一样，它们拥有通过程序运行的独立的并发路径，并且每个线程都有自己的程序计数器，称为堆栈和本地变量。然而，线程存在于进程中，它们与同一进程内的其他线程共享内存、文件句柄以及每进程状态。</p><p> 今天，几乎每个操作系统都支持线程，允许执行多个可独立调度的线程，以便共存于一个进程中。因为一个进程中的线程是在同一个地址空间中执行的，所以多个线程可以同时访问相同对象，并且它们从同一堆栈中分配对象。虽然这使线程更易于与其他线程共享信息，但也意味着您必须确保线程之间不相互干涉。</p><p> 正确使用线程时，线程能带来诸多好处，其中包括更好的资源利用、简化开发、高吞吐量、更易响应的用户界面以及能执行异步处理。</p><p> Java 语言包括用于协调线程行为的原语，从而可以在不违反设计原型或者不破坏数据结构的前提下安全地访问和修改共享变量。</p></li><li><p>线程有哪些功能？</p><p> 在 Java 程序中存在很多理由使用线程，并且不管开发人员知道线程与否，几乎每个 Java 应用程序都使用线程。许多 J2SE 和 J2EE 工具可以创建线程，如 RMI、Servlet、Enterprise JavaBeans 组件和 Swing GUI 工具包。</p></li><li><p>使用线程的理由包括：</p><p> • 更易响应的用户界面。 事件驱动的 GUI 工具包（如 AWT 或 Swing）使用单独的事件线程来处理 GUI 事件。从事件线程中调用通过 GUI 对象注册的事件监听器。然而，如果事件监听器将执行冗长的任务（如文档拼写检查），那么 UI 将出现冻结，因为事件线程直到冗长任务完毕之后才能处理其他事件。通过在单独线程中执行冗长操作，当执行冗长后台任务时，UI 能继续响应。</p><p> • 使用多处理器。 多处理器（MP）系统变得越来越便宜，并且分布越来越广泛。因为调度的基本单位通常是线程，所以不管有多少处理器可用，一个线程的应用程序一次只能在一个处理器上运行。在设计良好的程序中，通过更好地利用可用的计算机资源，多线程能够提高吞吐量和性能。</p><p> • 简化建模。 有效使用线程能够使程序编写变得更简单，并易于维护。通过合理使用线程，个别类可以避免一些调度的详细、交叉存取操作、异步 IO 和资源等待以及其他复杂问题。相反，它们能专注于域的要求，简化开发并改进可靠性。</p><p> • 异步或后台处理。 服务器应用程序可以同时服务于许多远程客户机。如果应用程序从 socket 中读取数据，并且没有数据可以读取，那么对 read() 的调用将被阻塞，直到有数据可读。在单线程应用程序中，这意味着当某一个线程被阻塞时，不仅处理相应请求要延迟，而且处理所有请求也将延迟。然而，如果每个 socket 都有自己的 IO 线程，那么当一个线程被阻塞时，对其他并发请求行为没有影响。</p></li><li><p>线程安全</p><p> 如果将这些类用于多线程环境中，虽然确保这些类的线程安全比较困难，但线程安全却是必需的。java.util.concurrent 规范进程的一个目标就是提供一组线程安全的、高性能的并发构建块，从而使开发人员能够减轻一些编写线程安全类的负担。</p><p> 线程安全类非常难以明确定义，大多数定义似乎都是完全循环的。快速 Google 搜索会显示下列线程安全代码定义的例子，但这些定义（或者更确切地说是描述）通常没什么帮助：</p><p> • . . . can be called from multiple programming threads without unwanted interaction between the threads.</p><p> • . . . may be called by more than on thread at a time without requiring any other action on the caller’s part.</p><p> 通过类似这样的定义，不奇怪我们为什么对线程安全如此迷惑。这些定义几乎就是在说”如果可以从多个线程安全调用类，那么该类就是线程安全的”。这当然是线程安全的解释，但对我们区别线程安全类和不安全类没有什么帮助。我们使用”安全”是为了说明什么？</p><p> 要成为线程安全的类，首先它必须在单线程环境中正确运行。如果正确实现了类，那么说明它符合规范，对该类的对象的任何顺序的操作（公共字段的读写、公共方法的调用）都不应该使对象处于无效状态；观察将处于无效状态的对象；或违反类的任何变量、前置条件或后置条件。</p><p> 而且，要成为线程安全的类，在从多个线程访问时，它必须继续正确运行，而不管运行时环境执行那些线程的调度和交叉，且无需对部分调用代码执行任何其他同步。结果是对线程安全对象的操作将用于按固定的整体一致顺序出现所有线程。</p><p> 如果没有线程之间的某种明确协调，比如锁定，运行时可以随意在需要时在多线程中交叉操作执行。</p><p> 在 JDK 5.0 之前，确保线程安全的主要机制是 synchronized 原语。访问共享变量（那些可以由多个线程访问的变量）的线程必须使用同步来协调对共享变量的读写访问。java.util.concurrent 包提供了一些备用并发原语，以及一组不需要任何其他同步的线程安全实用程序类。</p></li><li><p>令人厌烦的并发</p><p> 即使您的程序从没有明确创建线程，也可能会有许多工具或框架代表您创建了线程，这时要求从这些线程调用的类是线程安全的。这样会对开发人员带来较大的设计和实现负担，因为开发线程安全类比开发非线程安全类有更多要注意的事项，且需要更多的分析。</p></li><li><p>AWT 和 Swing</p><p> 这些 GUI 工具包创建了称为时间线程的后台线程，将从该线程调用通过 GUI 组件注册的监听器。因此，实现这些监听器的类必须是线程安全的。</p></li><li><p>TimerTask</p><p> JDK 1.3 中引入的 TimerTask 工具允许稍后执行任务或计划定期执行任务。在 Timer 线程中执行 TimerTask 事件，这意味着作为 TimerTask 执行的任务必须是线程安全的。</p></li><li><p>Servlet 和 JavaServer Page 技术</p><p> Servlet 容器可以创建多个线程，在多个线程中同时调用给定 servlet，从而进行多个请求。因此 servlet 类必须是线程安全的。</p></li><li><p>RMI</p><p> 远程方法调用（remote method invocation，RMI）工具允许调用其他 JVM 中运行的操作。实现远程对象最普遍的方法是扩展 UnicastRemoteObject。例示 UnicastRemoteObject 时，它是通过 RMI 调度器注册的，该调度器可能创建一个或多个线程，将在这些线程中执行远程方法。因此，远程类必须是线程安全的。</p><p> 正如所看到的，即使应用程序没有明确创建线程，也会发生许多可能会从其他线程调用类的情况。幸运的是，java.util.concurrent 中的类可以大大简化编写线程安全类的任务。</p></li></ol><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">例子 -- 非线程安全 servlet</span><br><span class="line"></span><br><span class="line">    下列 servlet 看起来像无害的留言板 servlet，它保存每个来访者的姓名。然而，该 servlet 不是线程安全的，而这个 servlet 应该是线程安全的。问题在于它使用 <span class="type">HashSet</span> 存储来访者的姓名，<span class="type">HashSet</span> 不是线程安全的类。</span><br><span class="line"></span><br><span class="line">    当我们说这个 servlet 不是线程安全的时，是说它所造成的破坏不仅仅是丢失留言板输入。在最坏的情况下，留言板数据结构都可能被破坏并且无法恢复。</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UnsafeGuestbookServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Set</span> visitorSet = <span class="keyword">new</span> <span class="type">HashSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> void doGet(<span class="type">HttpServletRequest</span> httpServletRequest,</span><br><span class="line"></span><br><span class="line">             <span class="type">HttpServletResponse</span> httpServletResponse) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> visitorName = httpServletRequest.getParameter(<span class="string">&quot;NAME&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visitorName != <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">            visitorSet.add(visitorName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    通过将 visitorSet 的定义更改为下列代码，可以使该类变为线程安全的：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Set</span> visitorSet = <span class="type">Collections</span>.synchronizedSet(<span class="keyword">new</span> <span class="type">HashSet</span>());</span><br><span class="line"></span><br><span class="line">    如上所示的例子显示线程的内置支持是一把双刃剑 -- 虽然它使构建多线程应用程序变得很容易，但它同时要求开发人员更加注意并发问题，甚至在使用留言板 servlet 这样普通的东西时也是如此。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h2><blockquote><blockquote><p>JDK 1.2 中引入的 Collection 框架是一种表示对象集合的高度灵活的框架，它使用基本接口 List、Set 和 Map。通过 JDK 提供每个集合的多次实现（HashMap、Hashtable、TreeMap、WeakHashMap、HashSet、TreeSet、Vector、ArrayList、LinkedList 等等）。其中一些集合已经是线程安全的（Hashtable 和 Vector），通过同步的封装工厂（Collections.synchronizedMap()、synchronizedList() 和 synchronizedSet()），其余的集合均可表现为线程安全的。<br>java.util.concurrent 包添加了多个新的线程安全集合类（ConcurrentHashMap、CopyOnWriteArrayList 和 CopyOnWriteArraySet）。这些类的目的是提供高性能、高度可伸缩性、线程安全的基本集合类型版本。<br>java.util 中的线程集合仍有一些缺点。例如，在迭代锁定时，通常需要将该锁定保留在集合中，否则，会有抛出 ConcurrentModificationException 的危险。（这个特性有时称为条件线程安全；有关的更多说明，请参阅参考资料。）此外，如果从多个线程频繁地访问集合，则常常不能很好地执行这些类。java.util.concurrent 中的新集合类允许通过在语义中的少量更改来获得更高的并发。<br>JDK 5.0 还提供了两个新集合接口 – Queue 和 BlockingQueue。Queue 接口与 List 类似，但它只允许从后面插入，从前面删除。通过消除 List 的随机访问要求，可以创建比现有 ArrayList 和 LinkedList 实现性能更好的 Queue 实现。因为 List 的许多应用程序实际上不需要随机访问，所以Queue 通常可以替代 List，来获得更好的性能。</p></blockquote></blockquote><ol><li><p>弱一致的迭代器</p><p> java.util 包中的集合类都返回 fail-fast 迭代器，这意味着它们假设线程在集合内容中进行迭代时，集合不会更改它的内容。如果 fail-fast 迭代器检测到在迭代过程中进行了更改操作，那么它会抛出 ConcurrentModificationException，这是不可控异常。</p><p> 在迭代过程中不更改集合的要求通常会对许多并发应用程序造成不便。相反，比较好的是它允许并发修改并确保迭代器只要进行合理操作，就可以提供集合的一致视图，如 java.util.concurrent 集合类中的迭代器所做的那样。</p><p> java.util.concurrent 集合返回的迭代器称为弱一致的（weakly consistent）迭代器。对于这些类，如果元素自从迭代开始已经删除，且尚未由 next() 方法返回，那么它将不返回到调用者。如果元素自迭代开始已经添加，那么它可能返回调用者，也可能不返回。在一次迭代中，无论如何更改底层集合，元素不会被返回两次。</p></li><li><p>CopyOnWriteArrayList 和 CopyOnWriteArraySet</p><p> 可以用两种方法创建线程安全支持数据的 List – Vector 或封装 ArrayList 和 Collections.synchronizedList()。java.util.concurrent 包添加了名称繁琐的 CopyOnWriteArrayList。为什么我们想要新的线程安全的List类？为什么Vector还不够？</p><p> 最简单的答案是与迭代和并发修改之间的交互有关。使用 Vector 或使用同步的 List 封装器，返回的迭代器是 fail-fast 的，这意味着如果在迭代过程中任何其他线程修改 List，迭代可能失败。</p></li><li><p>Vector 的非常普遍的应用程序是存储通过组件注册的监听器的列表。当发生适合的事件时，该组件将在监听器的列表中迭代，调用每个监听器。为了防止 ConcurrentModificationException，迭代线程必须复制列表或锁定列表，以便进行整体迭代，而这两种情况都需要大量的性能成本。</p></li><li><p>CopyOnWriteArrayList 类通过每次添加或删除元素时创建支持数组的新副本，避免了这个问题，但是进行中的迭代保持对创建迭代器时的当前副本进行操作。虽然复制也会有一些成本，但是在许多情况下，迭代要比修改多得多，在这些情况下，写入时复制要比其他备用方法具有更好的性能和并发性。</p></li><li><p>如果应用程序需要 Set 语义，而不是 List，那么还有一个 Set 版本 – CopyOnWriteArraySet。</p></li><li><p>ConcurrentHashMap</p><p> 正如已经存在线程安全的 List 的实现，您可以用多种方法创建线程安全的、基于 hash 的 Map – Hashtable，并使用 Collections.synchronizedMap() 封装 HashMap。JDK 5.0 添加了 ConcurrentHashMap 实现，该实现提供了相同的基本线程安全的 Map 功能，但它大大提高了并发性。</p><p> Hashtable 和 synchronizedMap 所采取的获得同步的简单方法（同步 Hashtable 中或者同步的 Map 封装器对象中的每个方法）有两个主要的不足。首先，这种方法对于可伸缩性是一种障碍，因为一次只能有一个线程可以访问 hash 表。同时，这样仍不足以提供真正的线程安全性，许多公用的混合操作仍然需要额外的同步。虽然诸如 get() 和 put() 之类的简单操作可以在不需要额外同步的情况下安全地完成，但还是有一些公用的操作序列，例如迭代或者 put-if-absent（空则放入），需要外部的同步，以避免数据争用。</p><p> Hashtable 和 Collections.synchronizedMap 通过同步每个方法获得线程安全。这意味着当一个线程执行一个 Map 方法时，无论其他线程要对 Map 进行什么样操作，都不能执行，直到第一个线程结束才可以。</p><p> 对比来说，ConcurrentHashMap 允许多个读取几乎总是并发执行，读和写操作通常并发执行，多个同时写入经常并发执行。结果是当多个线程需要访问同一 Map 时，可以获得更高的并发性。</p><p> 在大多数情况下，ConcurrentHashMap 是 Hashtable或 Collections.synchronizedMap(new HashMap()) 的简单替换。然而，其中有一个显著不同，即 ConcurrentHashMap 实例中的同步不锁定映射进行独占使用。实际上，没有办法锁定 ConcurrentHashMap 进行独占使用，它被设计用于进行并发访问。为了使集合不被锁定进行独占使用，还提供了公用的混合操作的其他（原子）方法，如 put-if-absent。ConcurrentHashMap 返回的迭代器是弱一致的，意味着它们将不抛出ConcurrentModificationException ，将进行”合理操作”来反映迭代过程中其他线程对 Map 的修改。</p></li><li><p>队列</p><p> 原始集合框架包含三个接口：List、Map 和 Set。List 描述了元素的有序集合，支持完全随即访问 – 可以在任何位置添加、提取或删除元素。</p><p> LinkedList 类经常用于存储工作元素（等待执行的任务）的列表或队列。然而，List 提供的灵活性比该公用应用程序所需要的多得多，这个应用程序通常在后面插入元素，从前面删除元素。但是要支持完整 List 接口则意味着 LinkedList 对于这项任务不像原来那样有效。Queue 接口比 List 简单得多，仅包含 put() 和 take() 方法，并允许比 LinkedList 更有效的实现。</p><p> Queue 接口还允许实现来确定存储元素的顺序。ConcurrentLinkedQueue 类实现先进先出（first-in-first-out，FIFO）队列，而 PriorityQueue 类实现优先级队列（也称为堆），它对于构建调度器非常有用，调度器必须按优先级或预期的执行时间执行任务。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Queue</span> <span class="keyword">extends</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 实现 Queue 的类是：</p><pre><code> • LinkedList 已经进行了改进来实现 Queue。 • PriorityQueue 非线程安全的优先级对列（堆）实现，根据自然顺序或比较器返回元素。 • ConcurrentLinkedQueue 快速、线程安全的、无阻塞 FIFO 队列。</code></pre></li><li><p>任务管理之线程创建</p><p> 线程最普遍的一个应用程序是创建一个或多个线程，以执行特定类型的任务。Timer 类创建线程来执行 TimerTask 对象，Swing 创建线程来处理 UI 事件。在这两种情况中，在单独线程中执行的任务都假定是短期的，这些线程是为了处理大量短期任务而存在的。</p><p> 在其中每种情况中，这些线程一般都有非常简单的结构：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (no tasks)</span><br><span class="line"></span><br><span class="line">    wait <span class="keyword">for</span> a task;</span><br><span class="line"></span><br><span class="line">  execute the task;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 通过例示从 Thread 获得的对象并调用 Thread.start() 方法来创建线程。可以用两种方法创建线程：通过扩展 Thread 和覆盖 run() 方法，或者通过实现 Runnable 接口和使用 Thread(Runnable) 构造函数：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/* do work */</span> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread t = <span class="keyword">new</span> WorkerThread();</span><br><span class="line"></span><br><span class="line">t.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 或者：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/* do work */</span> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>重新使用线程</p><p> 因为多个原因，类似 Swing GUI 的框架为事件任务创建单一线程，而不是为每项任务创建新的线程。首先是因为创建线程会有间接成本，所以创建线程来执行简单任务将是一种资源浪费。通过重新使用事件线程来处理多个事件，启动和拆卸成本（随平台而变）会分摊在多个事件上。</p><p> Swing 为事件使用单一后台线程的另一个原因是确保事件不会互相干涉，因为直到前一事件结束，下一事件才开始处理。该方法简化了事件处理程序的编写。</p><p> 使用多个线程，将要做更多的工作来确保一次仅一个线程地执行线程相关的代码。</p></li><li><p>如何不对任务进行管理</p><p> 大多数服务器应用程序（如 Web 服务器、POP 服务器、数据库服务器或文件服务器）代表远程客户机处理请求，这些客户机通常使用 socket 连接到服务器。对于每个请求，通常要进行少量处理（获得该文件的代码块，并将其发送回 socket），但是可能会有大量（且不受限制）的客户机请求服务。</p><p> 用于构建服务器应用程序的简单化模型会为每个请求创建新的线程。下列代码段实现简单的 Web 服务器，它接受端口 80 的 socket 连接，并创建新的线程来处理请求。不幸的是，该代码不是实现 Web 服务器的好方法，因为在重负载条件下它将失败，停止整台服务器。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnreliableWebServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line"></span><br><span class="line">      Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          handleRequest(connection);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Don&#x27;t do this!</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Thread(r).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当服务器被请求吞没时，UnreliableWebServer 类不能很好地处理这种情况。每次有请求时，就会创建新的类。根据操作系统和可用内存，可以创建的线程数是有限的。</p><p> 不幸的是，您通常不知道限制是多少 – 只有当应用程序因为 OutOfMemoryError 而崩溃时才发现。</p><p> 如果足够快地在这台服务器上抛出请求的话，最终其中一个线程创建将失败，生成的 Error 会关闭整个应用程序。当一次仅能有效支持很少线程时，没有必要创建上千个</p><p> 线程，无论如何，这样使用资源可能会损害性能。创建线程会使用相当一部分内存，其中包括有两个堆栈（Java 和 C），以及每线程数据结构。如果创建过多线程，其中</p><p> 每个线程都将占用一些 CPU 时间，结果将使用许多内存来支持大量线程，每个线程都运行得很慢。这样就无法很好地使用计算资源。</p></li><li><p>使用线程池解决问题</p><p> 为任务创建新的线程并不一定不好，但是如果创建任务的频率高，而平均任务持续时间低，我们可以看到每项任务创建一个新的线程将产生性能（如果负载不可预知，还有稳定性）问题。</p><p> 如果不是每项任务创建一个新的线程，则服务器应用程序必须采取一些方法来限制一次可以处理的请求数。这意味着每次需要启动新的任务时，它不能仅调用下列代码。</p><p> new Thread(runnable).start()</p><p> 管理一大组小任务的标准机制是组合工作队列和线程池。工作队列就是要处理的任务的队列，前面描述的 Queue 类完全适合。线程池是线程的集合，每个线程都提取公用工作队列。当一个工作线程完成任务处理后，它会返回队列，查看是否有其他任务需要处理。如果有，它会转移到下一个任务，并开始处理。</p><p> 线程池为线程生命周期间接成本问题和资源崩溃问题提供了解决方案。通过对多个任务重新使用线程，创建线程的间接成本将分布到多个任务中。作为一种额外好处，因为请求到达时，线程已经存在，从而可以消除由创建线程引起的延迟。因此，可以立即处理请求，使应用程序更易响应。而且，通过正确调整线程池中的线程数，可以强制超出特定限制的任何请求等待，直到有线程可以处理它，它们等待时所消耗的资源要少于使用额外线程所消耗的资源，这样可以防止资源崩溃。</p></li><li><p>Executor 框架</p><p> java.util.concurrent 包中包含灵活的线程池实现，但是更重要的是，它包含用于管理实现 Runnable 的任务的执行的整个框架。该框架称为 Executor 框架。</p><p> Executor 接口相当简单。它描述将运行 Runnable 的对象：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 任务运行于哪个线程不是由该接口指定的，这取决于使用的 Executor 的实现。它可以运行于后台线程，如 Swing 事件线程，或者运行于线程池，或者调用线程，或者新的线程，它甚至可以运行于其他 JVM！通过同步的 Executor 接口提交任务，从任务执行策略中删除任务提交。Executor 接口独自关注任务提交 – 这是Executor 实现的选择，确定执行策略。这使在部署时调整执行策略（队列限制、池大小、优先级排列等等）更加容易，更改的代码最少。</p><p> java.util.concurrent 中的大多数 Executor 实现还实现 ExecutorService 接口，这是对 Executor 的扩展，它还管理执行服务的生命周期。这使它们更易于管理，并向生命可能比单独 Executor 的生命更长的应用程序提供服务。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// other convenience methods for submitting tasks</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Executor</p><p> java.util.concurrent 包包含多个 Executor 实现，每个实现都实现不同的执行策略。什么是执行策略？执行策略定义何时在哪个线程中运行任务，执行任务可能消耗的资源级别（线程、内存等等），以及如果执行程序超载该怎么办。</p><p> 执行程序通常通过工厂方法例示，而不是通过构造函数。Executors 类包含用于构造许多不同类型的 Executor 实现的静态工厂方法：</p><p> • Executors.newCachedThreadPool() 创建不限制大小的线程池，但是当以前创建的线程可以使用时将重新使用那些线程。如果没有现有线程可用，</p><p> • 将创建新的线程并将其添加到池中。使用不到 60 秒的线程将终止并从缓存中删除。</p><p> • Executors.newFixedThreadPool(int n) 创建线程池，其重新使用在不受限制的队列之外运行的固定线程组。在关闭前，所有线程都会因为执行</p><p> • 过程中的失败而终止，如果需要执行后续任务，将会有新的线程来代替这些线程。</p><p> • Executors.newSingleThreadExecutor() 创建 Executor，其使用在不受限制的队列之外运行的单一工作线程，与 Swing 事件线程非常相似。</p><p> • 保证顺序执行任务，在任何给定时间，不会有多个任务处于活动状态。</p><p> 更可靠的 Web 服务器 – 使用 Executor</p><p> 前面 如何不对任务进行管理 中的代码显示了如何不用编写可靠服务器应用程序。幸运的是，修复这个示例非常简单，只需将 Thread.start() 调用替换为向 Executor 提交任务即可：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReliableWebServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Executor pool =</span><br><span class="line"></span><br><span class="line">    Executors.newFixedThreadPool(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line"></span><br><span class="line">      Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          handleRequest(connection);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      pool.execute(r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 注意，本例与前例之间的区别仅在于 Executor 的创建以及如何提交执行的任务。</p></li></ol><ol start="9"><li>定制 ThreadPoolExecutor</li></ol><blockquote><blockquote><p>Executors 中的 newFixedThreadPool 和 newCachedThreadPool 工厂方法返回的 Executor 是类 ThreadPoolExecutor 的实例，是高度可定制的。<br>通过使用包含 ThreadFactory 变量的工厂方法或构造函数的版本，可以定义池线程的创建。ThreadFactory 是工厂对象，其构造执行程序要使用的新线程。<br>使用定制的线程工厂，创建的线程可以包含有用的线程名称，并且这些线程是守护线程，属于特定线程组或具有特定优先级。<br>下面是线程工厂的例子，它创建守护线程，而不是创建用户线程：</p></blockquote></blockquote><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line"></span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>有时，Executor 不能执行任务，因为它已经关闭或者因为 Executor 使用受限制队列存储等待任务，而该队列已满。在这种情况下，需要咨询执行程序的 RejectedExecutionHandler 来确定如何处理任务 -- 抛出异常（默认情况），放弃任务，在调用者的线程中执行任务，或放弃队列中最早的任务以为新任务腾出空间。ThreadPoolExecutor.setRejectedExecutionHandler 可以设置拒绝的执行处理程序。还可以扩展 ThreadPoolExecutor，并覆盖方法 beforeExecute 和 afterExecute，以添加装置，添加记录，添加计时，重新初始化线程本地变量，或进行其他执行定制。 需要特别考虑的问题    使用 Executor 框架会从执行策略中删除任务提交，一般情况下，人们希望这样，那是因为它允许我们灵活地调整执行策略，不必更改许多位置的代码。然而，当提交代码暗含假设特定执行策略时，存在多种情况，在这些情况下，重要的是选择的 Executor 实现一致的执行策略。    这类情况中的其中的一种就是一些任务同时等待其他任务完成。在这种情况下，当线程池没有足够的线程时，如果所有当前执行的任务都在等待另一项任务，而该任务因为线程池已满不能执行，那么线程池可能会死锁。    另一种相似的情况是一组线程必须作为共同操作组一起工作。在这种情况下，需要确保线程池能够容纳所有线程。    如果应用程序对特定执行程序进行了特定假设，那么应该在 Executor 定义和初始化的附近对这些进行说明，从而使善意的更改不会破坏应用程序的正确功能。调整线程池    创建 Executor 时，人们普遍会问的一个问题是&quot;线程池应该有多大？&quot;。当然，答案取决于硬件和将执行的任务类型（它们是受计算限制或是受 IO 的限制？）。    如果线程池太小，资源可能不能被充分利用，在一些任务还在工作队列中等待执行时，可能会有处理器处于闲置状态。    另一方面，如果线程池太大，则将有许多有效线程，因为大量线程或有效任务使用内存，或者因为每项任务要比使用少量线程有更多上下文切换，性能可能会受损。    所以假设为了使处理器得到充分使用，线程池应该有多大？如果知道系统有多少处理器和任务的计算时间和等待时间的近似比率，Amdahl 法则提供很好的近似公式。    用 WT 表示每项任务的平均等待时间，ST 表示每项任务的平均服务时间（计算时间）。则 WT/ST 是每项任务等待所用时间的百分比。对于 N 处理器系统，池中可以近似有 N*(1+WT/ST) 个线程。    好的消息是您不必精确估计 WT/ST。&quot;合适的&quot;池大小的范围相当大；只需要避免&quot;过大&quot;和&quot;过小&quot;的极端情况即可。</code></pre><ol start="10"><li><p>Future 接口</p><p>Future 接口允许表示已经完成的任务、正在执行过程中的任务或者尚未开始执行的任务。通过 Future 接口，可以尝试取消尚未完成的任务，查询任务已经完成还是取消了，以及提取（或等待）任务的结果值。</p><p>FutureTask 类实现了 Future，并包含一些构造函数，允许将 Runnable 或 Callable（会产生结果的 Runnable）和 Future 接口封装。因为 FutureTask 也实现 Runnable，所以可以只将 FutureTask 提供给 Executor。一些提交方法（如 ExecutorService.submit()）除了提交任务之外，还将返回 Future 接口。</p><p>Future.get() 方法检索任务计算的结果（或如果任务完成，但有异常，则抛出 ExecutionException）。如果任务尚未完成，那么 Future.get() 将被阻塞，直到任务完成；如果任务已经完成，那么它将立即返回结果。</p><p>使用 Future 构建缓存</p><pre><code>该示例代码与 java.util.concurrent 中的多个类关联，突出显示了 Future 的功能。它实现缓存，使用 Future 描述缓存值，该值可能已经计算，或者可能在其他线程中&quot;正在构造&quot;。它利用 ConcurrentHashMap 中的原子 putIfAbsent() 方法，确保仅有一个线程试图计算给定关键字的值。如果其他线程随后请求同一关键字的值，它仅能等待（通过 Future.get() 的帮助）第一个线程完成。因此两个线程不会计算相同的值。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ConcurrentMap&gt; map = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    Executor executor = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        FutureTask f = map.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            Callable c = <span class="keyword">new</span> Callable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// return value associated with key</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            f = <span class="keyword">new</span> FutureTask(c);</span><br><span class="line"></span><br><span class="line">            FutureTask old = map.putIfAbsent(key, f);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (old == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">                executor.execute(f);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                f = old;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CompletionService</p><p>CompletionService 将执行服务与类似 Queue 的接口组合，从任务执行中删除任务结果的处理。CompletionService 接口包含用来提交将要执行的任务的 submit() 方法和用来询问下一完成任务的 take()/poll() 方法。</p><p>CompletionService 允许应用程序结构化，使用 Producer/Consumer 模式，其中生产者创建任务并提交，消费者请求完成任务的结果并处理这些结果。CompletionService 接口由 ExecutorCompletionService 类实现，该类使用 Executor 处理任务并从 CompletionService 导出 submit/poll/take 方法。</p><p>下列代码使用 Executor 和 CompletionService 来启动许多”solver”任务，并使用第一个生成非空结果的任务的结果，然后取消其余任务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Executor e, Collection&gt; solvers)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletionService ecs = <span class="keyword">new</span> ExecutorCompletionService(e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = solvers.size();</span><br><span class="line"></span><br><span class="line">        List&gt; futures = <span class="keyword">new</span> ArrayList&gt;(n);</span><br><span class="line"></span><br><span class="line">        Result result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Callable s : solvers)</span><br><span class="line"></span><br><span class="line">                futures.add(ecs.submit(s));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    Result r = ecs.take().get();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        result = r;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span>(ExecutionException ignore) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Future f : futures)</span><br><span class="line"></span><br><span class="line">                f.cancel(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">            use(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="java-util-concurrent-中其他类别的有用的类也是同步工具。这组类相互协作，控制一个或多个线程的执行流。"><a href="#java-util-concurrent-中其他类别的有用的类也是同步工具。这组类相互协作，控制一个或多个线程的执行流。" class="headerlink" title="java.util.concurrent 中其他类别的有用的类也是同步工具。这组类相互协作，控制一个或多个线程的执行流。"></a>java.util.concurrent 中其他类别的有用的类也是同步工具。这组类相互协作，控制一个或多个线程的执行流。</h2><p>Semaphore、CyclicBarrier、CountdownLatch 和 Exchanger 类都是同步工具的例子。每个类都有线程可以调用的方法，方法是否被阻塞取决于正在使用的特定同步工具的状态和规则。</p></li><li><p>Semaphore</p><p> Semaphore 类实现标准 Dijkstra 计数信号。计数信号可以认为具有一定数量的许可权，该许可权可以获得或释放。如果有剩余的许可权，acquire() 方法将成功，否则该方法将被阻塞，直到有可用的许可权（通过其他线程释放许可权）。线程一次可以获得多个许可权。</p><p> 计数信号可以用于限制有权对资源进行并发访问的线程数。该方法对于实现资源池或限制 Web 爬虫（Web crawler）中的输出 socket 连接非常有用。</p><p> 注意信号不跟踪哪个线程拥有多少许可权；这由应用程序来决定，以确保何时线程释放许可权，该信号表示其他线程拥有许可权或者正在释放许可权，以及其他线程知道它的许可权已释放。</p></li><li><p>互斥</p><p> 计数信号的一种特殊情况是互斥，或者互斥信号。互斥就是具有单一许可权的计数信号，意味着在给定时间仅一个线程可以具有许可权（也称为二进制信号）。互斥可以用于管理对共享资源的独占访问。</p><p> 虽然互斥许多地方与锁定一样，但互斥还有一个锁定通常没有的其他功能，就是互斥可以由具有许可权的线程之外的其他线程来释放。这在死锁恢复时会非常有用。</p><p> CyclicBarrier 类可以帮助同步，它允许一组线程等待整个线程组到达公共屏障点。CyclicBarrier 是使用整型变量构造的，其确定组中的线程数。当一个线程到达屏障时（通过调用 CyclicBarrier.await()），它会被阻塞，直到所有线程都到达屏障，然后在该点允许所有线程继续执行。该操作与许多家庭逛商业街相似 – 每个家庭成员都自己走，并商定 1:00 在电影院集合。当您到电影院但不是所有人都到了时，您会坐下来等其他人到达。然后所有人一起离开。</p><p> 认为屏障是循环的是因为它可以重新使用；一旦所有线程都已经在屏障处集合并释放，则可以将该屏障重新初始化到它的初始状态。 还可以指定在屏障处等待时的超时；如果在该时间内其余线程还没有到达屏障，则认为屏障被打破，所有正在等待的线程会收到 BrokenBarrierException。</p><p> 下列代码将创建 CyclicBarrier 并启动一组线程，每个线程将计算问题的一部分，等待所有其他线程结束之后，再检查解决方案是否达成一致。如果不一致，那么每个工作线程将开始另一个迭代。该例将使用 CyclicBarrier 变量，它允许注册 Runnable，在所有线程到达屏障但还没有释放任何线程时执行 Runnable。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solver</span> </span>&#123; <span class="comment">// Code sketch</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">final</span> Problem p, <span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> CyclicBarrier barrier =</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> CyclicBarrier(nThreads,</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; p.checkConvergence(); &#125;&#125;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; ++i) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> id = i;</span><br><span class="line"></span><br><span class="line">      Runnable worker = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Segment segment = p.createSegment(id);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!p.converged()) &#123;</span><br><span class="line"></span><br><span class="line">              segment.update();</span><br><span class="line"></span><br><span class="line">              barrier.await();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">catch</span>(Exception e) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Thread(worker).start();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CountdownLatch</p><p> CountdownLatch 类与 CyclicBarrier 相似，因为它的角色是对已经在它们中间分摊了问题的一组线程进行协调。它也是使用整型变量构造的，指明计数的初始值，但是与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。</p><p> 其中，CyclicBarrier 是到达屏障的所有线程的大门，只有当所有线程都已经到达屏障或屏障被打破时，才允许这些线程通过，CountdownLatch 将到达和等待功能分离。任何线程都可以通过调用 countDown() 减少当前计数，这种不会阻塞线程，而只是减少计数。await() 方法的行为与 CyclicBarrier.await() 稍微有所不同，调用 await() 任何线程都会被阻塞，直到闩锁计数减少为零，在该点等待的所有线程才被释放，对 await() 的后续调用将立即返回。</p><p> 当问题已经分解为许多部分，每个线程都被分配一部分计算时，CountdownLatch 非常有用。在工作线程结束时，它们将减少计数，协调线程可以在闩锁处等待当前这一批计算结束，然后继续移至下一批计算。</p><p> 相反地，具有计数 1 的 CountdownLatch 类可以用作”启动大门”，来立即启动一组线程；工作线程可以在闩锁处等待，协调线程减少计数，从而立即释放所有工作线程。下例使用两个 CountdownLatche。一个作为启动大门，一个在所有工作线程结束时释放线程：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">     CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">     doSomethingElse();            <span class="comment">// don&#x27;t let them run yet</span></span><br><span class="line"></span><br><span class="line">     startSignal.countDown();      <span class="comment">// let all threads proceed</span></span><br><span class="line"></span><br><span class="line">     doSomethingElse();</span><br><span class="line"></span><br><span class="line">     doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        startSignal.await();</span><br><span class="line"></span><br><span class="line">        doWork();</span><br><span class="line"></span><br><span class="line">        doneSignal.countDown();</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>Exchanger 类方便了两个共同操作线程之间的双向交换；这样，就像具有计数为 2 的 CyclicBarrier，并且两个线程在都到达屏障时可以”交换”一些状态。（Exchanger 模式有时也称为聚集。）</p><p> Exchanger 通常用于一个线程填充缓冲（通过读取 socket），而另一个线程清空缓冲（通过处理从 socket 收到的命令）的情况。当两个线程在屏障处集合时，它们交换缓冲。下列代码说明了这项技术：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FillAndEmpty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   Exchanger exchanger = <span class="keyword">new</span> Exchanger();</span><br><span class="line"></span><br><span class="line">   DataBuffer initialEmptyBuffer = <span class="keyword">new</span> DataBuffer();</span><br><span class="line"></span><br><span class="line">   DataBuffer initialFullBuffer = <span class="keyword">new</span> DataBuffer();</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">FillingLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       DataBuffer currentBuffer = initialEmptyBuffer;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span> (currentBuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">           addToBuffer(currentBuffer);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (currentBuffer.full())</span><br><span class="line"></span><br><span class="line">             currentBuffer = exchanger.exchange(currentBuffer);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ... &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">EmptyingLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       DataBuffer currentBuffer = initialFullBuffer;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span> (currentBuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">           takeFromBuffer(currentBuffer);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (currentBuffer.empty())</span><br><span class="line"></span><br><span class="line">             currentBuffer = exchanger.exchange(currentBuffer);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> Thread(<span class="keyword">new</span> FillingLoop()).start();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> Thread(<span class="keyword">new</span> EmptyingLoop()).start();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>锁定和原子之Lock</p><p> Java 语言内置了锁定工具 – synchronized 关键字。当线程获得监视器时（内置锁定），其他线程如果试图获得相同锁定，那么它们将被阻塞，直到第一个线程释放该锁定。同步还确保随后获得相同锁定的线程可以看到之前的线程在具有该锁定时所修改的变量的值，从而确保如果类正确地同步了共享状态的访问权，那么线程将不会看到变量的”失效”值，这是缓存或编译器优化的结果。</p><p> 虽然同步没有什么问题，但它有一些限制，在一些高级应用程序中会造成不便。Lock 接口将内置监视器锁定的锁定行为普遍化，允许多个锁定实现，同时提供一些内置锁定缺少的功能，如计时的等待、可中断的等待、锁定轮询、每个锁定有多个条件等待集合以及无阻塞结构的锁定。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> IE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                    TimeUnit unit)</span> <span class="keyword">throws</span> IE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                    UnsupportedOperationException</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>ReentrantLock</p><p> ReentrantLock 是具有与隐式监视器锁定（使用 synchronized 方法和语句访问）相同的基本行为和语义的 Lock 的实现，但它具有扩展的能力。</p><p> 作为额外收获，在竞争条件下，ReentrantLock 的实现要比现在的 synchronized 实现更具有可伸缩性。（有可能在 JVM 的将来版本中改进 synchronized 的竞争性能。）</p><p> 这意味着当许多线程都竞争相同锁定时，使用 ReentrantLock 的吞吐量通常要比 synchronized 好。换句话说，当许多线程试图访问 ReentrantLock 保护的共享资源时，JVM 将花费较少的时间来调度线程，而用更多个时间执行线程。</p><p> 虽然 ReentrantLock 类有许多优点，但是与同步相比，它有一个主要缺点 – 它可能忘记释放锁定。建议当获得和释放 ReentrantLock 时使用下列结构：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// perform operations protected by lock</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// restore invariants</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">  lock.unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 因为锁定失误（忘记释放锁定）的风险，所以对于基本锁定，强烈建议您继续使用 synchronized，除非真的需要 ReentrantLock 额外的灵活性和可伸缩性。</p><p> ReentrantLock 是用于高级应用程序的高级工具 – 有时需要，但有时用原来的方法就很好。</p></li><li><p>Condition</p><p> 就像 Lock 接口是同步的具体化，Condition 接口是 Object 中 wait() 和 notify() 方法的具体化。Lock 中的一个方法是 newCondition()，它要求锁定向该锁定返回新的 Condition 对象限制。await()、signal() 和 signalAll() 方法类似于 wait()、notify() 和 notifyAll()，但增加了灵活性，每个 Lock 都可以创建多个条件变量。这简化了一些并发算法的实现。</p></li><li><p>ReadWriteLock</p><p> ReentrantLock 实现的锁定规则非常简单 – 每当一个线程具有锁定时，其他线程必须等待，直到该锁定可用。有时，当对数据结构的读取通常多于修改时，可以使用更复杂的称为读写锁定的锁定结构，它允许有多个并发读者，同时还允许一个写入者独占锁定。该方法在一般情况下（只读）提供了更大的并发性，同时在必要时仍提供独占访问的安全性。ReadWriteLock 接口和 ReentrantReadWriteLock 类提供这种功能 – 多读者、单写入者锁定规则，可以用这种功能来保护共享的易变资源。</p></li><li><p>原子变量</p><p> 即使大多数用户将很少直接使用它们，原子变量类（AtomicInteger、AtomicLong、AtomicReference 等等）也有充分理由是最显著的新并发类。这些类公开对 JVM 的低级别改进，允许进行具有高度可伸缩性的原子读-修改-写操作。大多数现代 CPU 都有原子读-修改-写的原语，比如比较并交换（CAS）或加载链接/条件存储（LL/SC）。原子变量类使用硬件提供的最快的并发结构来实现。</p><p> 许多并发算法都是根据对计数器或数据结构的比较并交换操作来定义的。通过暴露高性能的、高度可伸缩的 CAS 操作（以原子变量的形式），用 Java 语言实现高性能、无等待、无锁定的并发算法已经变得可行。</p><p> 几乎 java.util.concurrent 中的所有类都是在 ReentrantLock 之上构建的，ReentrantLock 则是在原子变量类的基础上构建的。所以，虽然仅少数并发专家使用原子变量类，但 java.util.concurrent 类的很多可伸缩性改进都是由它们提供的。</p><p> 原子变量主要用于为原子地更新”热”字段提供有效的、细粒度的方式，”热”字段是指由多个线程频繁访问和更新的字段。另外，原子变量还是计数器或生成序号的自然机制。</p></li><li><p>性能与可伸缩性</p><p>虽然 java.util.concurrent 努力的首要目标是使编写正确、线程安全的类更加容易，但它还有一个次要目标，就是提供可伸缩性。可伸缩性与性能完全不同，实际上，可伸缩性有时要以性能为代价来获得。</p><p>性能是”可以快速执行此任务的程度”的评测。可伸缩性描述应用程序的吞吐量如何表现为它的工作量和可用计算资源增加。可伸缩的程序可以按比例使用更多的处理器、内存或 I/O 带宽来处理更多个工作量。当我们在并发环境中谈论可伸缩性时，我们是在问当许多线程同时访问给定类时，这个类的执行情况。</p><p>java.util.concurrent 中的低级别类 ReentrantLock 和原子变量类的可伸缩性要比内置监视器（同步）锁定高得多。因此，使用 ReentrantLock 或原子变量类来协调共享访问的类也可能更具有可伸缩性。</p></li><li><p>Hashtable 与 ConcurrentHashMap</p><p>作为可伸缩性的例子，ConcurrentHashMap 实现设计的可伸缩性要比其线程安全的上一代 Hashtable 的可伸缩性强得多。Hashtable 一次只允许一个线程访问 Map；ConcurrentHashMap 允许多个读者并发执行，读者与写入者并发执行，以及一些写入者并发执行。因此，如果许多线程频繁访问共享映射，使用 ConcurrentHashMap 的总的吞吐量要比使用 Hashtable 的好。</p><p>下表大致说明了 Hashtable 和 ConcurrentHashMap 之间的可伸缩性差别。在每次运行时，N 个线程并发执行紧密循环，它们从 Hashtable 或 ConcurrentHashMap 中检索随即关键字，60% 的失败检索将执行 put() 操作，2% 的成功检索执行 remove() 操作。测试在运行 Linux 的双处理器 Xeon 系统中执行。数据显示 10,000,000 个迭代的运行时间，对于 ConcurrentHashMap，标准化为一个线程的情况。可以看到直到许多线程，ConcurrentHashMap 的性能仍保持可伸缩性，而 Hashtable 的性能在出现锁定竞争时几乎立即下降。</p><p>与通常的服务器应用程序相比，这个测试中的线程数看起来很少。然而，因为每个线程未进行其他操作，仅是重复地选择使用该表，所以这样可以模拟在执行一些实际工作的情况下使用该表的大量线程的竞争。</p><table><thead><tr><th align="center">线程</th><th align="center">ConcurrentHashMap</th><th align="center">Hashtable</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1.0</td><td align="center">1.51</td></tr><tr><td align="center">2</td><td align="center">1.44</td><td align="center">17.09</td></tr><tr><td align="center">4</td><td align="center">1.83</td><td align="center">29.9</td></tr><tr><td align="center">8</td><td align="center">4.06</td><td align="center">54.06</td></tr><tr><td align="center">16</td><td align="center">7.5</td><td align="center">119.44</td></tr><tr><td align="center">32</td><td align="center">15.32</td><td align="center">237.2</td></tr></tbody></table></li><li><p>Lock 与 synchronized 与原子</p><p>下列基准说明了使用 java.util.concurrent 可能改进可伸缩性的例子。该基准将模拟旋转骰子，使用线性同余随机数生成器。有三个可用的随机数生成器的实现：一个使用同步来管理生成器的状态（单一变量），一个使用 ReentrantLock，另一个则使用 AtomicLong。下图显示了在 8-way Ultrasparc3 系统上，逐渐增加线程数量时这三个版本的相对吞吐量。（该图对原子变量方法的可伸缩性描述比较保守。）</p></li></ol><ol start="13"><li><p>公平与不公平</p><p>java.util.concurrent 中许多类中的另外一个定制元素是”公平”的问题。公平锁定或公平信号是指在其中根据先进先出（FIFO）的原则给与线程锁定或信号。ReentrantLock、Semaphore 和 ReentrantReadWriteLock 的构造函数都可以使用变量确定锁定是否公平，或者是否允许闯入（线程获得锁定，即使它们等待的时间不是最长）。</p><p>虽然闯入锁定的想法可能有些可笑，但实际上不公平、闯入的锁定非常普遍，且通常很受欢迎。使用同步访问的内置锁定不是公平锁定（且没有办法使它们公平）。相反，它们提供较弱的生病保证，要求所有线程最终都将获得锁定。</p><p>大多数应用程序选择（且应该选择）闯入锁定而不是公平锁定的原因是性能。在大多数情况下，完全的公平不是程序正确性的要求，真正公平的成本相当高。下表向前面的面板中的表中添加了第四个数据集，并由一个公平锁定管理对 PRNG 状态的访问。注意闯入锁定与公平锁定之间吞吐量的巨大差别。</p></li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><pre><code>java.util.concurrent 包中包含大量有用的构建快，可以用它们来改进并发类的性能、可伸缩性、线程安全和可维护性。通过这些构建快，应该可以不再需要在您的代码中大量使用同步、wait/notify 和 Thread.start()，而用更高级别、标准化的、高性能并发实用程序来替换它们。Exchanger,CyclicBarrier,Synchronizer</code></pre><hr><p>本文由 blog博主Caoer（草儿）原创，此处为转载。</p><p>由于原文两张图片不方便显示,这里暂时去掉，转载时本博(<a href="http://www.blogjava.net/mlh123caoer/archive/2007/10/24/155474.html)%E9%87%8D%E6%96%B0%E5%BC%95%E7%94%A8%E4%BA%86%E5%9B%BE%E7%89%87%EF%BC%8C%E5%B9%B6%E8%B0%83%E6%95%B4%E4%BA%86%E7%89%88%E9%9D%A2%E3%80%82">http://www.blogjava.net/mlh123caoer/archive/2007/10/24/155474.html)重新引用了图片，并调整了版面。</a></p><p>如原创作者认为本文侵权，请通知本博。</p><blockquote><blockquote><p><a href="http://tutorials.jenkov.com/java-concurrency/index.html">并发参考学习</a></p></blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;java.util.concurrent 包含许多线程安全、测试良好、高性能的并发构建块。不客气地说，创建 java.util.concurrent 的目的就是要实现 Collection 框架对数据结构所执行的并发操作。</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="http://example.com/2016/10/13/dubbo/"/>
    <id>http://example.com/2016/10/13/dubbo/</id>
    <published>2016-10-13T07:12:23.000Z</published>
    <updated>2022-09-03T10:12:16.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo在项目中的作用"><a href="#Dubbo在项目中的作用" class="headerlink" title="Dubbo在项目中的作用"></a>Dubbo在项目中的作用</h2><p>分布式服务架构</p><ol><li><p>当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。<br>并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover，降低对F5硬件负载均衡器的依赖，也能减少部分成本。</p></li><li><p>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。<br>这时，需要自动画出应用间的依赖关系图，以帮助架构师理清理关系。</p></li><li><p>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？<br>为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。<br>其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p></li></ol><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ol><li>Provider: 暴露服务的服务提供方。</li><li>Consumer: 调用远程服务的服务消费方。</li><li>Registry: 服务注册与发现的注册中心。</li><li>Monitor: 统计服务的调用次调和调用时间的监控中心。</li><li>Container: 服务运行容器。</li></ol><h3 id="调用关系"><a href="#调用关系" class="headerlink" title="调用关系"></a>调用关系</h3><ol start="0"><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Dubbo在项目中的作用&quot;&gt;&lt;a href=&quot;#Dubbo在项目中的作用&quot; class=&quot;headerlink&quot; title=&quot;Dubbo在项目中的作用&quot;&gt;&lt;/a&gt;Dubbo在项目中的作用&lt;/h2&gt;&lt;p&gt;分布式服务架构&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当服务越来越</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="服务治理" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    <category term="rpc" scheme="http://example.com/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>Paxos</title>
    <link href="http://example.com/2016/09/16/paxos/"/>
    <id>http://example.com/2016/09/16/paxos/</id>
    <published>2016-09-16T06:58:22.000Z</published>
    <updated>2022-09-03T10:12:16.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作者介绍"><a href="#作者介绍" class="headerlink" title="作者介绍"></a>作者介绍</h2><p>1982，Lamport 提出了一种计算机容错理论，并于1900年论证。<br>这是一种<br>基于消传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。</p><blockquote><p>时间时钟、面包店算法、拜占庭将军及paxos算法的创建性容错</p></blockquote><h2 id="paxos的目的"><a href="#paxos的目的" class="headerlink" title="paxos的目的"></a>paxos的目的</h2><p>  提高分布式系统容错性的一致性算法</p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>  一致性算法</p><h2 id="算法三个角色："><a href="#算法三个角色：" class="headerlink" title="算法三个角色："></a>算法三个角色：</h2><p>  Proposer<br>  Acceptor<br>  Learner</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="paxos-描述："><a href="#paxos-描述：" class="headerlink" title="paxos 描述："></a>paxos 描述：</h3><p>  参与者之间可以进行通信，可以记录一些信息，来确定最终的值<br>  消息内容不会被篡改</p><h3 id="知行学社的分布式系统与Paxos算法-对paxos算法核心思想的描述"><a href="#知行学社的分布式系统与Paxos算法-对paxos算法核心思想的描述" class="headerlink" title="知行学社的分布式系统与Paxos算法 对paxos算法核心思想的描述"></a>知行学社的分布式系统与Paxos算法 对paxos算法核心思想的描述</h3><ul><li><p>在抢占式访问权的基础上引入多acceptor</p></li><li><p>保证一个epoch,只有一个proposer运行，proposer按照epoch递增的顺序依次运行。</p></li><li><p>新的epoch的proposer采用后者认同前者的思路运行。</p></li><li><p>在肯定旧epoch无法生成确定性取值时，新的epoch 会提交自己的取值。不会冲突。</p></li><li><p>一旦旧epoch形成确定性取值，新epoch肯定可以获取到此取值，并且会认同此取值，不会破坏。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;作者介绍&quot;&gt;&lt;a href=&quot;#作者介绍&quot; class=&quot;headerlink&quot; title=&quot;作者介绍&quot;&gt;&lt;/a&gt;作者介绍&lt;/h2&gt;&lt;p&gt;1982，Lamport 提出了一种计算机容错理论，并于1900年论证。&lt;br&gt;这是一种&lt;br&gt;基于消传递且具有高度容错特性</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="一致性算法" scheme="http://example.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
    <category term="CAP" scheme="http://example.com/tags/CAP/"/>
    
  </entry>
  
  <entry>
    <title>MAC下完成人脸检测代码环境构建</title>
    <link href="http://example.com/2016/09/15/MAC%E4%B8%8B%E5%AE%8C%E6%88%90%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E4%BB%A3%E7%A0%81%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/"/>
    <id>http://example.com/2016/09/15/MAC%E4%B8%8B%E5%AE%8C%E6%88%90%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E4%BB%A3%E7%A0%81%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/</id>
    <published>2016-09-15T10:29:07.000Z</published>
    <updated>2022-09-03T10:12:16.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>工作中用到图片的截图，但在使用过程中出现了一个尴尬的问题，就是截图时，有的人没有了头<br>，只留下身子.</p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>通过代码来检测出头部所以位置，然后来决定载哪些区域（目前，只是对一个人进行剪切。</p><h2 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h2><ol><li><p>找到一个合适的类库来进行人头位置检测</p><pre><code> _python-opencv_</code></pre></li><li><p>使用python 对人裁剪范围进行处理(GraphicsMagick)得到想要的区域</p></li></ol><h2 id="正题-如何在MAC上安装开发环境"><a href="#正题-如何在MAC上安装开发环境" class="headerlink" title="正题 如何在MAC上安装开发环境"></a>正题 如何在MAC上安装开发环境</h2><p>利用  python-opencv 库<br><a href="http://www.pyimagesearch.com/2015/06/15/install-opencv-3-0-and-python-2-7-on-osx/">http://www.pyimagesearch.com/2015/06/15/install-opencv-3-0-and-python-2-7-on-osx/</a></p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=<span class="regexp">/usr/</span>local \</span><br><span class="line">-D PYTHON2_PACKAGES_PATH=~<span class="regexp">/.virtualenvs/</span>cv<span class="regexp">/lib/</span>python2.<span class="number">7</span>/site-packages \</span><br><span class="line">-D</span><br><span class="line">PYTHON2_LIBRARY=<span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>python<span class="regexp">/2.7.10/</span>Frameworks<span class="regexp">/Python.framework/</span>Versions<span class="regexp">/2.7/</span>bin</span><br><span class="line">\</span><br><span class="line">-D PYTHON2_INCLUDE_DIR=<span class="regexp">/usr/</span>local<span class="regexp">/Frameworks/</span>Python.framework/Headers \</span><br><span class="line">-D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON \</span><br><span class="line">-D BUILD_EXAMPLES=ON \</span><br><span class="line">-D OPENCV_EXTRA_MODULES_PATH=~<span class="regexp">/opencv_contrib/m</span>odules ..</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <a href="http://docs.opencv.org/2.4/doc/tutorials/introduction/linux_install/linux_install.html#linux-installation">http://docs.opencv.org/2.4/doc/tutorials/introduction/linux_install/linux_install.html#linux-installation</a></p> <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">brew</span> <span class="string">tap homebrew/science</span></span><br><span class="line"><span class="attr">brew</span> <span class="string">install opencv3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_objdetect/py_face_detection/py_face_detection.html">http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_objdetect/py_face_detection/py_face_detection.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;工作中用到图片的截图，但在使用过程中出现了一个尴尬的问题，就是截图时，有的人没有了头&lt;br&gt;，只留下身子.&lt;/p&gt;
&lt;h2 id=&quot;解决方式</summary>
      
    
    
    
    <category term="方案" scheme="http://example.com/categories/%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="图片处理" scheme="http://example.com/tags/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/"/>
    
    <category term="人脸识别" scheme="http://example.com/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>第N次百望山到植物园</title>
    <link href="http://example.com/2016/09/12/%E7%AC%ACN%E6%AC%A1%E7%99%BE%E6%9C%9B%E5%B1%B1%E5%88%B0%E6%A4%8D%E7%89%A9%E5%9B%AD/"/>
    <id>http://example.com/2016/09/12/%E7%AC%ACN%E6%AC%A1%E7%99%BE%E6%9C%9B%E5%B1%B1%E5%88%B0%E6%A4%8D%E7%89%A9%E5%9B%AD/</id>
    <published>2016-09-12T11:23:10.000Z</published>
    <updated>2022-09-03T21:57:32.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么是N次"><a href="#为什么是N次" class="headerlink" title="为什么是N次"></a>为什么是N次</h2><p>2015年已经多次走这样同一个路线</p><h2 id="为什么第N次记录了一下"><a href="#为什么第N次记录了一下" class="headerlink" title="为什么第N次记录了一下"></a>为什么第N次记录了一下</h2><p>之前来走的时候都是正常13公里，到植物园进行小息游园后坐公交回家。但是这次遇到了一些事情，也许今后不会再次走这条路，故在此进行记录</p><h2 id="百望山路段"><a href="#百望山路段" class="headerlink" title="百望山路段"></a>百望山路段</h2><p>不得不说百望山发展之迅速，从去年到今天常走的路基本上都已经修成了马路，真的是‘大功’ 一件，这样子人们就不用走泥路了，也不用那么接地气了  <del>~</del></p><h2 id="百望山到黑山头路段"><a href="#百望山到黑山头路段" class="headerlink" title="百望山到黑山头路段"></a>百望山到黑山头路段</h2><p>这段路不算长，也就二三公里的样子，不过曾经一个人走过N次。清醒的记得去年走的一幕幕，黑黑的，阴阴的，凉凉的，热热的，鸟儿到处都是，有时甚至还有蛐蛐在歌唱。真可以说精神上的放松。期间老婆也走过一两次，由于全程走下来比较累，基本上都是我一个人在走。<br>基本上每次走完，一周都感到比较轻松。</p><h2 id="黑山头到冷泉村防火道"><a href="#黑山头到冷泉村防火道" class="headerlink" title="黑山头到冷泉村防火道"></a>黑山头到冷泉村防火道</h2><p>这路其实都一两个比较大的景点，也许只有我自己认为那算做景点吧！</p><h3 id="山泉"><a href="#山泉" class="headerlink" title="山泉"></a>山泉</h3><p>若想去山泉取水，每次要多走2公里。一般情况下会想去但是由于后面路程的问题会选择赶路。这次我去了，其实也是被迫了基本上。嘿嘿</p><h3 id="天泉寺"><a href="#天泉寺" class="headerlink" title="天泉寺"></a>天泉寺</h3><p>今天才知道这个寺届是 <code>天泉寺</code> 之前走到这里总感觉是一片废墟，从没想过这地如此的大。这次到这里，发现有人在整修，并且已经把原来的地基轮廓都已经整理出来。<br>在这里呆了差不多一个小时，感叹时间的厉害，也感叹我们在时间长流中是那么微不足道。<br>后来又来到寺庙傍边的佛塔傍边，从佛塔的视角可以看清楚整个寺庙的全景。于是我便非常想知道，这个寺庙到底经历了哪些历史…</p><p><img src="/images/tianquansi/IMG_1938.jpg"><br><img src="/images/tianquansi/IMG_1939.jpg"><br><img src="/images/tianquansi/IMG_1940.jpg"><br><img src="/images/tianquansi/IMG_1941.jpg"><br><img src="/images/tianquansi/IMG_1942.jpg"><br><img src="/images/tianquansi/IMG_1943.jpg"><br><img src="/images/tianquansi/IMG_1944.jpg"><br><img src="/images/tianquansi/IMG_1947.jpg"><br><img src="/images/tianquansi/IMG_1948.jpg"><br><img src="/images/tianquansi/IMG_1949.jpg"><br><img src="/images/tianquansi/IMG_1950.jpg"><br><img src="/images/tianquansi/IMG_1951.jpg"><br><img src="/images/tianquansi/IMG_1958.jpg"><br><img src="/images/tianquansi/IMG_1959.jpg"><br><img src="/images/tianquansi/IMG_1963.jpg"></p><h2 id="冷泉村到植物园"><a href="#冷泉村到植物园" class="headerlink" title="冷泉村到植物园"></a>冷泉村到植物园</h2><p>这次走了一半，在去植物园的路已经被我们解放军战士把守，说是军事重地，人民不能进入。我问了一下，他们说可以从别的地方翻跃过去。同时我也看到有一帮人从这些士兵可见的范围内进行翻跃围墙。有一种说不出来的心情充上心头，但感觉在我们体制下好多类似的事情发生，从而又感叹了一些国家怎么样才能提高全民素质等等事情～～～～</p><p>我可不想去翻墙，我还是回寺庙再去看看，同时去喝些泉水，也好久没有去泉眼了。<br>今天泉水非常多，有一位好心的兄弟给帮我搞了一水袋。我便带着回家了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>不知道下次什么时候才能再进行穿越，希望放开这块路线供大家穿越。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么是N次&quot;&gt;&lt;a href=&quot;#为什么是N次&quot; class=&quot;headerlink&quot; title=&quot;为什么是N次&quot;&gt;&lt;/a&gt;为什么是N次&lt;/h2&gt;&lt;p&gt;2015年已经多次走这样同一个路线&lt;/p&gt;
&lt;h2 id=&quot;为什么第N次记录了一下&quot;&gt;&lt;a href=&quot;#为</summary>
      
    
    
    
    <category term="生活" scheme="http://example.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="人生感悟" scheme="http://example.com/tags/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
    <category term="运动" scheme="http://example.com/tags/%E8%BF%90%E5%8A%A8/"/>
    
    <category term="爬山" scheme="http://example.com/tags/%E7%88%AC%E5%B1%B1/"/>
    
  </entry>
  
  <entry>
    <title>图片处理环境构建</title>
    <link href="http://example.com/2016/09/12/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/"/>
    <id>http://example.com/2016/09/12/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/</id>
    <published>2016-09-12T08:30:53.000Z</published>
    <updated>2022-09-03T10:12:16.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对存储的文件进行并发处理，由于处理的图片量比较大。<br>图片处理又比较耗内存，为防止影响正常的服务，故将其与业务服务分开部署</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>python+uwsgi+imagemagick</p><h2 id="环境安装："><a href="#环境安装：" class="headerlink" title="环境安装："></a>环境安装：</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span>配置</span><br><span class="line">     <span class="number">16</span>Core,<span class="number">16</span>G内存，<span class="number">50</span>G硬盘</span><br><span class="line"><span class="number">2.</span>端口</span><br><span class="line">    <span class="number">13814</span>（fcp），<span class="number">8010</span>(http)</span><br><span class="line"><span class="number">3.</span>安装 graphicsmagick</span><br><span class="line">     jasper<span class="number">-1.900</span><span class="number">.1</span>.zip  jpegsrc.v9a.tar.gz</span><br><span class="line"></span><br><span class="line">wget http:<span class="comment">//www.imagemagick.org/download/delegates/jpegsrc.v9a.tar.gz</span></span><br><span class="line">wget http:<span class="comment">//www.ece.uvic.ca/~frodo/jasper/software/jasper-1.900.1.zip</span></span><br><span class="line">gm 命令ln /usr/local/graphicsmagick/bin/gm usr/bin/gm</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>装音频插件和字体</span><br><span class="line">http:<span class="comment">//my.oschina.net/ethan09/blog/372435?fromerr=WsZSucMx</span></span><br><span class="line">安装微软雅黑字体</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>python版本升级</span><br><span class="line">http:<span class="comment">//blog.csdn.net/jcjc918/article/details/11022345  由于django必须要用2.7，所以这里要进行升级</span></span><br><span class="line">注意修改完后  要修改/usr/bin/supervisord,/usr/bin/supervisorctl 的头为/usr/bin/python2<span class="number">.6</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>重新安装pip和c++库</span><br><span class="line">wget https:<span class="comment">//bootstrap.pypa.io/get-pip.py</span></span><br><span class="line">python <span class="keyword">get</span>-pip.py</span><br><span class="line"></span><br><span class="line">安装c++库</span><br><span class="line">sudo yum install GraphicsMagick-c++-devel</span><br><span class="line">sudo yum install boost-devel</span><br><span class="line"><span class="number">7.</span>安装python插件</span><br><span class="line"></span><br><span class="line">sudo pip install -r requirements.txt</span><br><span class="line">requirements.txt内容</span><br><span class="line">Django==<span class="number">1.9</span><span class="number">.7</span></span><br><span class="line">beautifulsoup4==<span class="number">4.4</span><span class="number">.1</span></span><br><span class="line">protobuf==<span class="number">2.6</span><span class="number">.1</span></span><br><span class="line">pgmagick==<span class="number">0.6</span><span class="number">.2</span></span><br><span class="line">uWSGI==<span class="number">2.0</span><span class="number">.13</span><span class="number">.1</span></span><br><span class="line">wsgiref==<span class="number">0.1</span><span class="number">.2</span></span><br><span class="line">django-log-request-id==<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>安装nginx</span><br><span class="line">yum install nginx</span><br><span class="line"><span class="number">9.</span>安装uwsgi</span><br><span class="line">sudo yum install uwsgi</span><br><span class="line">sudo yum install uwsgi-plugin-python</span><br><span class="line"></span><br><span class="line">nginx配置</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">  uwsgi_pass unix:<span class="comment">///tmp/uwsgi.sock;</span></span><br><span class="line">  include /etc/nginx/uwsgi_params; # the uwsgi_params file you installed</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">client_max_body_size <span class="number">20</span>M;</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span>安装图片处理服务</span><br><span class="line">cd /opt/fs/</span><br><span class="line">git clone http:<span class="comment">//git.firstshare.cn/Qixin/FSPythonWSGIProcess.git</span></span><br><span class="line">cd FSPythonWSGIProcess</span><br><span class="line"></span><br><span class="line">uwsgi --ini online_uwsgi.ini --buffer-size <span class="number">20971520</span>   --daemonize ./logs/uwsgi.log</span><br><span class="line"></span><br><span class="line"><span class="number">11.</span>异常</span><br><span class="line">*** Starting uWSGI <span class="number">2.0</span><span class="number">.12</span> (<span class="number">64</span>bit) on [Tue Jun <span class="number">14</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">20</span> <span class="number">2016</span>] ***</span><br><span class="line">compiled with version: <span class="number">4.4</span><span class="number">.7</span> <span class="number">20120313</span> (Red Hat <span class="number">4.4</span><span class="number">.7</span><span class="number">-16</span>) on <span class="number">02</span> January <span class="number">2016</span> <span class="number">19</span>:<span class="number">53</span>:<span class="number">13</span></span><br><span class="line">os: Linux<span class="number">-2.6</span><span class="number">.32</span><span class="number">-573.8</span><span class="number">.1</span>.el6.x86_64 #<span class="number">1</span> SMP Tue Nov <span class="number">10</span> <span class="number">18</span>:<span class="number">01</span>:<span class="number">38</span> UTC <span class="number">2015</span></span><br><span class="line">nodename: vlnx160170.fsceshi.com</span><br><span class="line">machine: x86_64</span><br><span class="line">clock source: unix</span><br><span class="line">pcre jit disabled</span><br><span class="line">detected number of CPU cores: <span class="number">4</span></span><br><span class="line">current working directory: /home/wans/FSPythonWSGIProcess</span><br><span class="line">writing pidfile to /tmp/FsPythonWSGIProcess.pid</span><br><span class="line">detected binary path: /usr/sbin/uwsgi</span><br><span class="line">your processes number limit <span class="keyword">is</span> <span class="number">1024</span></span><br><span class="line">your memory page size <span class="keyword">is</span> <span class="number">4096</span> bytes</span><br><span class="line">detected max file descriptor number: <span class="number">60000</span></span><br><span class="line">lock engine: pthread robust mutexes</span><br><span class="line">thunder lock: disabled (you can enable it with --thunder-lock)</span><br><span class="line">uwsgi socket <span class="number">0</span> bound to UNIX address /tmp/uwsgi.sock fd <span class="number">4</span></span><br><span class="line">your server socket listen backlog <span class="keyword">is</span> limited to <span class="number">100</span> connections</span><br><span class="line">your mercy <span class="keyword">for</span> graceful operations on workers <span class="keyword">is</span> <span class="number">60</span> seconds</span><br><span class="line">mapped <span class="number">1476277</span> bytes (<span class="number">1441</span> KB) <span class="keyword">for</span> <span class="number">10</span> cores</span><br><span class="line">*** Operational MODE: preforking ***</span><br><span class="line">*** no app loaded. going <span class="keyword">in</span> full dynamic mode ***</span><br><span class="line"></span><br><span class="line">关闭nginx   ,启动uwsgi后再启动nginx</span><br><span class="line"></span><br><span class="line">优化点：</span><br><span class="line"><span class="number">1.</span>调整nginx</span><br><span class="line">worker_processes     <span class="number">4</span>;</span><br><span class="line">worker_cpu_affinity <span class="number">1000</span> <span class="number">0100</span> <span class="number">0010</span> <span class="number">0001</span>;</span><br><span class="line"><span class="number">2.</span>#cluster</span><br><span class="line">upstream backend&#123;</span><br><span class="line">server unix:<span class="comment">///tmp/uwsgi.sock;</span></span><br><span class="line">server unix:<span class="comment">///tmp/uwsgi1.sock;</span></span><br><span class="line">server unix:<span class="comment">///tmp/uwsgi2.sock;</span></span><br><span class="line">server unix:<span class="comment">///tmp/uwsgi3.sock;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">                    include uwsgi_params;</span><br><span class="line">uwsgi_pass backend;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">问题总结:</span><br><span class="line"><span class="number">1.</span>yum安装遇到如下类似问题:</span><br><span class="line">        yum install uwsgi</span><br><span class="line">        Loaded plugins: fastestmirror</span><br><span class="line">        Loading mirror speeds <span class="keyword">from</span> cached hostfile</span><br><span class="line">         * base: mirrors.btte.net</span><br><span class="line">         * extras: mirrors.btte.net</span><br><span class="line">         * updates: mirrors<span class="number">.163</span>.com</span><br><span class="line">        No package uwsgi available.</span><br><span class="line">        Error: Nothing to <span class="keyword">do</span></span><br><span class="line">   解决方案,添加epl至yum的源即可:</span><br><span class="line">   yum install http:<span class="comment">//mirrors.isu.net.sa/pub/fedora/fedora-epel/7/x86_64/e/epel-release-7-6.noarch.rpm</span></span><br><span class="line">   参考文档:https:<span class="comment">//fedoraproject.org/wiki/EPEL/zh-cn</span></span><br><span class="line">   </span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;对存储的文件进行并发处理，由于处理的图片量比较大。&lt;br&gt;图片处理又比较耗内存，为防止影响正常的服务，故将其与业务服务分开部署&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="方案" scheme="http://example.com/categories/%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="nginx" scheme="http://example.com/tags/nginx/"/>
    
    <category term="fastcgi" scheme="http://example.com/tags/fastcgi/"/>
    
    <category term="图片处理" scheme="http://example.com/tags/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>我的音乐目录</title>
    <link href="http://example.com/2016/01/10/%E6%88%91%E7%9A%84%E9%9F%B3%E4%B9%90%E7%9B%AE%E5%BD%95/"/>
    <id>http://example.com/2016/01/10/%E6%88%91%E7%9A%84%E9%9F%B3%E4%B9%90%E7%9B%AE%E5%BD%95/</id>
    <published>2016-01-09T16:00:00.000Z</published>
    <updated>2022-09-03T10:12:16.076Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Django</p></li><li><p>当我老了</p></li><li><p>朋友</p></li><li><p>冬季到台北来看你</p></li></ul>]]></content>
    
    
    <summary type="html">music</summary>
    
    
    
    <category term="生活" scheme="http://example.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="音乐" scheme="http://example.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>将amr,caf转mp3</title>
    <link href="http://example.com/2015/12/27/%E5%B0%86amr,caf%E8%BD%ACmp3/"/>
    <id>http://example.com/2015/12/27/%E5%B0%86amr,caf%E8%BD%ACmp3/</id>
    <published>2015-12-26T16:00:00.000Z</published>
    <updated>2022-09-03T10:12:16.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><hr><p><code>公司原有文件存储现在要用java进行重构，其中涉及到Android和ios上的音频问题。</code></p><ol><li><p>Android录音是格式是amr，在电脑上一般是播放不出来的，必须要进行转码。</p></li><li><p>iPhone录音传上来的是caf，在android上是不能进行播放的。</p></li></ol><p><code>由于上面的问题，我们要进行文件的转换，另外还有一个需求就是，amr转wav ,这里我们将amr和caf统一转换为map3,另外提供一个接口进行amr2wav的转换。 在网上参考了许多，总结下来还都是调用ffmpeg 进行想着音频的转换。总也来说比较简单。这里时间的关系 ，也不可能去研究底层编解码的东西。</code></p><hr><h1 id="开工"><a href="#开工" class="headerlink" title="开工"></a>开工</h1><h2 id="安装ffmpeg"><a href="#安装ffmpeg" class="headerlink" title="安装ffmpeg"></a>安装<a href="https://www.ffmpeg.org/ffmpeg.html#Audio-Options">ffmpeg</a></h2><ul><li>参考<a href="http://my.oschina.net/ethan09/blog/372435">http://my.oschina.net/ethan09/blog/372435</a></li></ul><h2 id="查看当前ffmpeg对mp3的编解码支持情况"><a href="#查看当前ffmpeg对mp3的编解码支持情况" class="headerlink" title="查看当前ffmpeg对mp3的编解码支持情况"></a>查看当前ffmpeg对mp3的编解码支持情况</h2><pre><code>    ffmpeg -codecs|grep mp3                                             D.A.L. mp3                  MP3 (MPEG audio layer 3) (decoders: mp3 mp3float )     D.A.L. mp3adu               ADU (Application Data Unit) MP3 (MPEG audio layer 3) (decoders: mp3adu mp3adufloat )     D.A.L. mp3on4               MP3onMP4 (decoders: mp3on4 mp3on4float )     </code></pre><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>ffmpeg: error while loading shared libraries: libavdevice.so.53: cannot open shared object file: No such file or directory</li></ul><pre><code>      ffmpeg正常安装后执行ffmpeg时出现如下错误：      解决办法：      vi /etc/ld.so.conf      加入：/usr/local/lib      执行ldconfig</code></pre><ul><li><p>ffmpeg -i test.amr test.mp3<br>ffmpeg: error while loading shared libraries: libavdevice.so.56: cannot open shared object file: No such file or directory</p><pre><code> &lt;http://www.tjcarroll.org/?p=51&gt;</code></pre></li></ul>]]></content>
    
    
    <summary type="html">Java android amr caf mp3</summary>
    
    
    
    <category term="方案" scheme="http://example.com/categories/%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="音频转换" scheme="http://example.com/tags/%E9%9F%B3%E9%A2%91%E8%BD%AC%E6%8D%A2/"/>
    
    <category term="arm" scheme="http://example.com/tags/arm/"/>
    
    <category term="mp3" scheme="http://example.com/tags/mp3/"/>
    
  </entry>
  
  <entry>
    <title>FASTDFS</title>
    <link href="http://example.com/2015/12/08/FASTFS/"/>
    <id>http://example.com/2015/12/08/FASTFS/</id>
    <published>2015-12-07T16:00:00.000Z</published>
    <updated>2022-09-03T10:12:16.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.oschina.net/p/fastdfs">基本介绍</a></li></ul>]]></content>
    
    
    <summary type="html">Java fastfs</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="存储" scheme="http://example.com/tags/%E5%AD%98%E5%82%A8/"/>
    
    <category term="fastfs" scheme="http://example.com/tags/fastfs/"/>
    
  </entry>
  
  <entry>
    <title>git工作与学习</title>
    <link href="http://example.com/2015/12/08/git%E5%B7%A5%E4%BD%9C%E4%B8%8E%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2015/12/08/git%E5%B7%A5%E4%BD%9C%E4%B8%8E%E5%AD%A6%E4%B9%A0/</id>
    <published>2015-12-07T16:00:00.000Z</published>
    <updated>2022-09-03T10:12:16.076Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tag的作用与学习"><a href="#tag的作用与学习" class="headerlink" title="tag的作用与学习"></a>tag的作用与学习</h3><ul><li><p>git tag ‘name’ -m ‘desc’ 创建</p></li><li><p>git tag -d ‘name’ 删除</p></li><li><p>git tag -l  查看</p></li><li><p>git push –tags 提交</p></li><li><p>git push origin :refs/tags/tags_name</p></li></ul><h3 id="git-在使用项目中的实践模型"><a href="#git-在使用项目中的实践模型" class="headerlink" title="git 在使用项目中的实践模型"></a>git 在使用项目中的实践模型</h3><ol><li>master</li><li>release-6.1</li><li>develop</li><li>hotfix-xxx</li><li>release-release-6.1-xx</li></ol><h3 id="批量删除tag"><a href="#批量删除tag" class="headerlink" title="批量删除tag"></a>批量删除tag</h3><p>git tag |grep -v ‘v7.2.25-log_report_v9-20200909’ | xargs -I {} git tag -d {}</p>]]></content>
    
    
    <summary type="html">Java git</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="经验" scheme="http://example.com/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
    <category term="代码仓库" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
</feed>
