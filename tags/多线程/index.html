<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Tag: 多线程 | Share</title>
  <meta name="description" content="生活点滴和知识分享" />
  <meta name="keywords" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/">
  <link rel="alternate" href="/atom.xml" title="Share" type="application/atom+xml">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="生活点滴和知识分享">
<meta property="og:type" content="website">
<meta property="og:title" content="Share">
<meta property="og:url" content="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Share">
<meta property="og:description" content="生活点滴和知识分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="万松">
<meta name="twitter:card" content="summary">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				Share
			</a>

			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/'>
								主页
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/archives'>
								分类查看
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/about'>
								关于我
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search flat-box"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/" class="nav-home nav">
				主页
			</a>
		
			<a href="/archives" class="nav-archives nav">
				分类查看
			</a>
		
			<a href="/about" class="nav-about nav">
				关于我
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        
  <script>
    window.subData= { title:'Tag : 多线程'}
  </script>

<section class="post-list">
	
    <div class='post-wrapper'>
      <article class="post reveal">
    <section class="meta">
        
            <h2 class="title">
                <a href="/2018/03/24/java-util-concurrent%E6%A6%82%E8%A7%88/">
                    java.util.concurrent概览
                </a>
            </h2>
        
        <time>
            3月 24, 2018
        </time>
        
    
    <div class='cats'>
        <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
    </div>

    </section>
    <section class="article typo">
        <blockquote>
<blockquote>
<p>java.util.concurrent 包含许多线程安全、测试良好、高性能的并发构建块。不客气地说，创建 java.util.concurrent 的目的就是要实现 Collection 框架对数据结构所执行的并发操作。通过提供一组可靠的、高性能并发构建块，开发人员可以提高并发类的线程安全、可伸缩性、性能、可读性和可靠性。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如果一些类名看起来相似，可能是因为 java.util.concurrent 中的许多概念源自 Doug Lea 的 util.concurrent 库（请参阅 参考资料）。</p>
</blockquote>
</blockquote>
<h2 id="JDK-5-0-中的并发改进可以分为三组："><a href="#JDK-5-0-中的并发改进可以分为三组：" class="headerlink" title="JDK 5.0 中的并发改进可以分为三组："></a>JDK 5.0 中的并发改进可以分为三组：</h2><pre><code>1. JVM 级别更改。

    大多数现代处理器对并发对某一硬件级别提供支持，通常以 compare-and-swap （CAS）指令形式。CAS 是一种低级别的、细粒度的技术，它允许多个线程更新一个内存位置，同时能够检测其他线程的冲突并进行恢复。它是许多高性能并发算法的基础。在 JDK 5.0 之前，Java 语言中用于协调线程之间的访问的惟一原语是同步，同步是更重量级和粗粒度的。公开 CAS 可以开发高度可伸缩的并发 Java 类。这些更改主要由 JDK 库类使用，而不是由开发人员使用。

2. 低级实用程序类 -- 锁定和原子类。

    使用 CAS 作为并发原语，ReentrantLock 类提供与 synchronized 原语相同的锁定和内存语义，然而这样可以更好地控制锁定（如计时的锁定等待、锁定轮询和可中断的锁定等待）和提供更好的可伸缩性（竞争时的高性能）。大多数开发人员将不再直接使用 ReentrantLock 类，而是使用在 ReentrantLock 类上构建的高级类。

3. 高级实用程序类。

    这些类实现并发构建块，每个计算机科学文本中都会讲述这些类 -- 信号、互斥、闩锁、屏障、交换程序、线程池和线程安全集合类等。大部分开发人员都可以在应用程序中用这些类，来替换许多（如果不是全部）同步、wait() 和 notify() 的使用，从而提高性能、可读性和正确性。</code></pre>
<h2 id="本文主要内容"><a href="#本文主要内容" class="headerlink" title="本文主要内容"></a>本文主要内容</h2><pre><code>本教程将重点介绍 java.util.concurrent 包提供的高级实用程序类 -- 线程安全集合、线程池和同步实用程序。这些是初学者和专家都可以使用的&quot;现成&quot;类。

在第一小节中，我们将回顾并发的基本知识，尽管它不应取代对线程和线程安全的了解。那些一点都不熟悉线程的读者应该先参考一些关于线程的介绍，如&quot;Introduction to Java Threads&quot;教程（请参阅参考资料）。

接下来的几个小节将研究 java.util.concurrent 中的高级实用程序类 -- 线程安全集合、线程池、信号和同步工具。

最后一小节将介绍 java.util.concurrent 中的低级并发构建块，并提供一些性能测评来显示新 java.util.concurrent 类的可伸缩性的改进。</code></pre>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>什么是线程？</p>
<p> 所有重要的操作系统都支持进程的概念 – 独立运行的程序，在某种程度上相互隔离。</p>
<p> 线程有时称为 轻量级进程。与进程一样，它们拥有通过程序运行的独立的并发路径，并且每个线程都有自己的程序计数器，称为堆栈和本地变量。然而，线程存在于进程中，它们与同一进程内的其他线程共享内存、文件句柄以及每进程状态。</p>
<p> 今天，几乎每个操作系统都支持线程，允许执行多个可独立调度的线程，以便共存于一个进程中。因为一个进程中的线程是在同一个地址空间中执行的，所以多个线程可以同时访问相同对象，并且它们从同一堆栈中分配对象。虽然这使线程更易于与其他线程共享信息，但也意味着您必须确保线程之间不相互干涉。</p>
<p> 正确使用线程时，线程能带来诸多好处，其中包括更好的资源利用、简化开发、高吞吐量、更易响应的用户界面以及能执行异步处理。</p>
<p> Java 语言包括用于协调线程行为的原语，从而可以在不违反设计原型或者不破坏数据结构的前提下安全地访问和修改共享变量。</p>
</li>
<li><p>线程有哪些功能？</p>
<p> 在 Java 程序中存在很多理由使用线程，并且不管开发人员知道线程与否，几乎每个 Java 应用程序都使用线程。许多 J2SE 和 J2EE 工具可以创建线程，如 RMI、Servlet、Enterprise JavaBeans 组件和 Swing GUI 工具包。</p>
</li>
<li><p>使用线程的理由包括：</p>
<p> • 更易响应的用户界面。 事件驱动的 GUI 工具包（如 AWT 或 Swing）使用单独的事件线程来处理 GUI 事件。从事件线程中调用通过 GUI 对象注册的事件监听器。然而，如果事件监听器将执行冗长的任务（如文档拼写检查），那么 UI 将出现冻结，因为事件线程直到冗长任务完毕之后才能处理其他事件。通过在单独线程中执行冗长操作，当执行冗长后台任务时，UI 能继续响应。</p>
<p> • 使用多处理器。 多处理器（MP）系统变得越来越便宜，并且分布越来越广泛。因为调度的基本单位通常是线程，所以不管有多少处理器可用，一个线程的应用程序一次只能在一个处理器上运行。在设计良好的程序中，通过更好地利用可用的计算机资源，多线程能够提高吞吐量和性能。</p>
<p> • 简化建模。 有效使用线程能够使程序编写变得更简单，并易于维护。通过合理使用线程，个别类可以避免一些调度的详细、交叉存取操作、异步 IO 和资源等待以及其他复杂问题。相反，它们能专注于域的要求，简化开发并改进可靠性。</p>
<p> • 异步或后台处理。 服务器应用程序可以同时服务于许多远程客户机。如果应用程序从 socket 中读取数据，并且没有数据可以读取，那么对 read() 的调用将被阻塞，直到有数据可读。在单线程应用程序中，这意味着当某一个线程被阻塞时，不仅处理相应请求要延迟，而且处理所有请求也将延迟。然而，如果每个 socket 都有自己的 IO 线程，那么当一个线程被阻塞时，对其他并发请求行为没有影响。</p>
</li>
<li><p>线程安全</p>
<p> 如果将这些类用于多线程环境中，虽然确保这些类的线程安全比较困难，但线程安全却是必需的。java.util.concurrent 规范进程的一个目标就是提供一组线程安全的、高性能的并发构建块，从而使开发人员能够减轻一些编写线程安全类的负担。</p>
<p> 线程安全类非常难以明确定义，大多数定义似乎都是完全循环的。快速 Google 搜索会显示下列线程安全代码定义的例子，但这些定义（或者更确切地说是描述）通常没什么帮助：</p>
<p> • . . . can be called from multiple programming threads without unwanted interaction between the threads.</p>
<p> • . . . may be called by more than on thread at a time without requiring any other action on the caller’s part.</p>
<p> 通过类似这样的定义，不奇怪我们为什么对线程安全如此迷惑。这些定义几乎就是在说”如果可以从多个线程安全调用类，那么该类就是线程安全的”。这当然是线程安全的解释，但对我们区别线程安全类和不安全类没有什么帮助。我们使用”安全”是为了说明什么？</p>
<p> 要成为线程安全的类，首先它必须在单线程环境中正确运行。如果正确实现了类，那么说明它符合规范，对该类的对象的任何顺序的操作（公共字段的读写、公共方法的调用）都不应该使对象处于无效状态；观察将处于无效状态的对象；或违反类的任何变量、前置条件或后置条件。</p>
<p> 而且，要成为线程安全的类，在从多个线程访问时，它必须继续正确运行，而不管运行时环境执行那些线程的调度和交叉，且无需对部分调用代码执行任何其他同步。结果是对线程安全对象的操作将用于按固定的整体一致顺序出现所有线程。</p>
<p> 如果没有线程之间的某种明确协调，比如锁定，运行时可以随意在需要时在多线程中交叉操作执行。</p>
<p> 在 JDK 5.0 之前，确保线程安全的主要机制是 synchronized 原语。访问共享变量（那些可以由多个线程访问的变量）的线程必须使用同步来协调对共享变量的读写访问。java.util.concurrent 包提供了一些备用并发原语，以及一组不需要任何其他同步的线程安全实用程序类。</p>
</li>
<li><p>令人厌烦的并发</p>
<p> 即使您的程序从没有明确创建线程，也可能会有许多工具或框架代表您创建了线程，这时要求从这些线程调用的类是线程安全的。这样会对开发人员带来较大的设计和实现负担，因为开发线程安全类比开发非线程安全类有更多要注意的事项，且需要更多的分析。</p>
</li>
<li><p>AWT 和 Swing</p>
<p> 这些 GUI 工具包创建了称为时间线程的后台线程，将从该线程调用通过 GUI 组件注册的监听器。因此，实现这些监听器的类必须是线程安全的。</p>
</li>
<li><p>TimerTask</p>
<p> JDK 1.3 中引入的 TimerTask 工具允许稍后执行任务或计划定期执行任务。在 Timer 线程中执行 TimerTask 事件，这意味着作为 TimerTask 执行的任务必须是线程安全的。</p>
</li>
<li><p>Servlet 和 JavaServer Page 技术</p>
<p> Servlet 容器可以创建多个线程，在多个线程中同时调用给定 servlet，从而进行多个请求。因此 servlet 类必须是线程安全的。</p>
</li>
<li><p>RMI</p>
<p> 远程方法调用（remote method invocation，RMI）工具允许调用其他 JVM 中运行的操作。实现远程对象最普遍的方法是扩展 UnicastRemoteObject。例示 UnicastRemoteObject 时，它是通过 RMI 调度器注册的，该调度器可能创建一个或多个线程，将在这些线程中执行远程方法。因此，远程类必须是线程安全的。</p>
<p> 正如所看到的，即使应用程序没有明确创建线程，也会发生许多可能会从其他线程调用类的情况。幸运的是，java.util.concurrent 中的类可以大大简化编写线程安全类的任务。</p>
</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">例子 -- 非线程安全 servlet</span><br><span class="line"></span><br><span class="line">    下列 servlet 看起来像无害的留言板 servlet，它保存每个来访者的姓名。然而，该 servlet 不是线程安全的，而这个 servlet 应该是线程安全的。问题在于它使用 <span class="type">HashSet</span> 存储来访者的姓名，<span class="type">HashSet</span> 不是线程安全的类。</span><br><span class="line"></span><br><span class="line">    当我们说这个 servlet 不是线程安全的时，是说它所造成的破坏不仅仅是丢失留言板输入。在最坏的情况下，留言板数据结构都可能被破坏并且无法恢复。</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UnsafeGuestbookServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Set</span> visitorSet = <span class="keyword">new</span> <span class="type">HashSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> void doGet(<span class="type">HttpServletRequest</span> httpServletRequest,</span><br><span class="line"></span><br><span class="line">             <span class="type">HttpServletResponse</span> httpServletResponse) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> visitorName = httpServletRequest.getParameter(<span class="string">&quot;NAME&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visitorName != <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">            visitorSet.add(visitorName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    通过将 visitorSet 的定义更改为下列代码，可以使该类变为线程安全的：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Set</span> visitorSet = <span class="type">Collections</span>.synchronizedSet(<span class="keyword">new</span> <span class="type">HashSet</span>());</span><br><span class="line"></span><br><span class="line">    如上所示的例子显示线程的内置支持是一把双刃剑 -- 虽然它使构建多线程应用程序变得很容易，但它同时要求开发人员更加注意并发问题，甚至在使用留言板 servlet 这样普通的东西时也是如此。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h2><blockquote>
<blockquote>
<p>JDK 1.2 中引入的 Collection 框架是一种表示对象集合的高度灵活的框架，它使用基本接口 List、Set 和 Map。通过 JDK 提供每个集合的多次实现（HashMap、Hashtable、TreeMap、WeakHashMap、HashSet、TreeSet、Vector、ArrayList、LinkedList 等等）。其中一些集合已经是线程安全的（Hashtable 和 Vector），通过同步的封装工厂（Collections.synchronizedMap()、synchronizedList() 和 synchronizedSet()），其余的集合均可表现为线程安全的。<br>java.util.concurrent 包添加了多个新的线程安全集合类（ConcurrentHashMap、CopyOnWriteArrayList 和 CopyOnWriteArraySet）。这些类的目的是提供高性能、高度可伸缩性、线程安全的基本集合类型版本。<br>java.util 中的线程集合仍有一些缺点。例如，在迭代锁定时，通常需要将该锁定保留在集合中，否则，会有抛出 ConcurrentModificationException 的危险。（这个特性有时称为条件线程安全；有关的更多说明，请参阅参考资料。）此外，如果从多个线程频繁地访问集合，则常常不能很好地执行这些类。java.util.concurrent 中的新集合类允许通过在语义中的少量更改来获得更高的并发。<br>JDK 5.0 还提供了两个新集合接口 – Queue 和 BlockingQueue。Queue 接口与 List 类似，但它只允许从后面插入，从前面删除。通过消除 List 的随机访问要求，可以创建比现有 ArrayList 和 LinkedList 实现性能更好的 Queue 实现。因为 List 的许多应用程序实际上不需要随机访问，所以Queue 通常可以替代 List，来获得更好的性能。</p>
</blockquote>
</blockquote>
<ol>
<li><p>弱一致的迭代器</p>
<p> java.util 包中的集合类都返回 fail-fast 迭代器，这意味着它们假设线程在集合内容中进行迭代时，集合不会更改它的内容。如果 fail-fast 迭代器检测到在迭代过程中进行了更改操作，那么它会抛出 ConcurrentModificationException，这是不可控异常。</p>
<p> 在迭代过程中不更改集合的要求通常会对许多并发应用程序造成不便。相反，比较好的是它允许并发修改并确保迭代器只要进行合理操作，就可以提供集合的一致视图，如 java.util.concurrent 集合类中的迭代器所做的那样。</p>
<p> java.util.concurrent 集合返回的迭代器称为弱一致的（weakly consistent）迭代器。对于这些类，如果元素自从迭代开始已经删除，且尚未由 next() 方法返回，那么它将不返回到调用者。如果元素自迭代开始已经添加，那么它可能返回调用者，也可能不返回。在一次迭代中，无论如何更改底层集合，元素不会被返回两次。</p>
</li>
<li><p>CopyOnWriteArrayList 和 CopyOnWriteArraySet</p>
<p> 可以用两种方法创建线程安全支持数据的 List – Vector 或封装 ArrayList 和 Collections.synchronizedList()。java.util.concurrent 包添加了名称繁琐的 CopyOnWriteArrayList。为什么我们想要新的线程安全的List类？为什么Vector还不够？</p>
<p> 最简单的答案是与迭代和并发修改之间的交互有关。使用 Vector 或使用同步的 List 封装器，返回的迭代器是 fail-fast 的，这意味着如果在迭代过程中任何其他线程修改 List，迭代可能失败。</p>
</li>
<li><p>Vector 的非常普遍的应用程序是存储通过组件注册的监听器的列表。当发生适合的事件时，该组件将在监听器的列表中迭代，调用每个监听器。为了防止 ConcurrentModificationException，迭代线程必须复制列表或锁定列表，以便进行整体迭代，而这两种情况都需要大量的性能成本。</p>
</li>
<li><p>CopyOnWriteArrayList 类通过每次添加或删除元素时创建支持数组的新副本，避免了这个问题，但是进行中的迭代保持对创建迭代器时的当前副本进行操作。虽然复制也会有一些成本，但是在许多情况下，迭代要比修改多得多，在这些情况下，写入时复制要比其他备用方法具有更好的性能和并发性。</p>
</li>
<li><p>如果应用程序需要 Set 语义，而不是 List，那么还有一个 Set 版本 – CopyOnWriteArraySet。</p>
</li>
<li><p>ConcurrentHashMap</p>
<p> 正如已经存在线程安全的 List 的实现，您可以用多种方法创建线程安全的、基于 hash 的 Map – Hashtable，并使用 Collections.synchronizedMap() 封装 HashMap。JDK 5.0 添加了 ConcurrentHashMap 实现，该实现提供了相同的基本线程安全的 Map 功能，但它大大提高了并发性。</p>
<p> Hashtable 和 synchronizedMap 所采取的获得同步的简单方法（同步 Hashtable 中或者同步的 Map 封装器对象中的每个方法）有两个主要的不足。首先，这种方法对于可伸缩性是一种障碍，因为一次只能有一个线程可以访问 hash 表。同时，这样仍不足以提供真正的线程安全性，许多公用的混合操作仍然需要额外的同步。虽然诸如 get() 和 put() 之类的简单操作可以在不需要额外同步的情况下安全地完成，但还是有一些公用的操作序列，例如迭代或者 put-if-absent（空则放入），需要外部的同步，以避免数据争用。</p>
<p> Hashtable 和 Collections.synchronizedMap 通过同步每个方法获得线程安全。这意味着当一个线程执行一个 Map 方法时，无论其他线程要对 Map 进行什么样操作，都不能执行，直到第一个线程结束才可以。</p>
<p> 对比来说，ConcurrentHashMap 允许多个读取几乎总是并发执行，读和写操作通常并发执行，多个同时写入经常并发执行。结果是当多个线程需要访问同一 Map 时，可以获得更高的并发性。</p>
<p> 在大多数情况下，ConcurrentHashMap 是 Hashtable或 Collections.synchronizedMap(new HashMap()) 的简单替换。然而，其中有一个显著不同，即 ConcurrentHashMap 实例中的同步不锁定映射进行独占使用。实际上，没有办法锁定 ConcurrentHashMap 进行独占使用，它被设计用于进行并发访问。为了使集合不被锁定进行独占使用，还提供了公用的混合操作的其他（原子）方法，如 put-if-absent。ConcurrentHashMap 返回的迭代器是弱一致的，意味着它们将不抛出ConcurrentModificationException ，将进行”合理操作”来反映迭代过程中其他线程对 Map 的修改。</p>
</li>
<li><p>队列</p>
<p> 原始集合框架包含三个接口：List、Map 和 Set。List 描述了元素的有序集合，支持完全随即访问 – 可以在任何位置添加、提取或删除元素。</p>
<p> LinkedList 类经常用于存储工作元素（等待执行的任务）的列表或队列。然而，List 提供的灵活性比该公用应用程序所需要的多得多，这个应用程序通常在后面插入元素，从前面删除元素。但是要支持完整 List 接口则意味着 LinkedList 对于这项任务不像原来那样有效。Queue 接口比 List 简单得多，仅包含 put() 和 take() 方法，并允许比 LinkedList 更有效的实现。</p>
<p> Queue 接口还允许实现来确定存储元素的顺序。ConcurrentLinkedQueue 类实现先进先出（first-in-first-out，FIFO）队列，而 PriorityQueue 类实现优先级队列（也称为堆），它对于构建调度器非常有用，调度器必须按优先级或预期的执行时间执行任务。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Queue</span> <span class="keyword">extends</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 实现 Queue 的类是：</p>
<pre><code> • LinkedList 已经进行了改进来实现 Queue。

 • PriorityQueue 非线程安全的优先级对列（堆）实现，根据自然顺序或比较器返回元素。

 • ConcurrentLinkedQueue 快速、线程安全的、无阻塞 FIFO 队列。</code></pre>
</li>
<li><p>任务管理之线程创建</p>
<p> 线程最普遍的一个应用程序是创建一个或多个线程，以执行特定类型的任务。Timer 类创建线程来执行 TimerTask 对象，Swing 创建线程来处理 UI 事件。在这两种情况中，在单独线程中执行的任务都假定是短期的，这些线程是为了处理大量短期任务而存在的。</p>
<p> 在其中每种情况中，这些线程一般都有非常简单的结构：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (no tasks)</span><br><span class="line"></span><br><span class="line">    wait <span class="keyword">for</span> a task;</span><br><span class="line"></span><br><span class="line">  execute the task;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 通过例示从 Thread 获得的对象并调用 Thread.start() 方法来创建线程。可以用两种方法创建线程：通过扩展 Thread 和覆盖 run() 方法，或者通过实现 Runnable 接口和使用 Thread(Runnable) 构造函数：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/* do work */</span> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread t = <span class="keyword">new</span> WorkerThread();</span><br><span class="line"></span><br><span class="line">t.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 或者：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/* do work */</span> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>重新使用线程</p>
<p> 因为多个原因，类似 Swing GUI 的框架为事件任务创建单一线程，而不是为每项任务创建新的线程。首先是因为创建线程会有间接成本，所以创建线程来执行简单任务将是一种资源浪费。通过重新使用事件线程来处理多个事件，启动和拆卸成本（随平台而变）会分摊在多个事件上。</p>
<p> Swing 为事件使用单一后台线程的另一个原因是确保事件不会互相干涉，因为直到前一事件结束，下一事件才开始处理。该方法简化了事件处理程序的编写。</p>
<p> 使用多个线程，将要做更多的工作来确保一次仅一个线程地执行线程相关的代码。</p>
</li>
<li><p>如何不对任务进行管理</p>
<p> 大多数服务器应用程序（如 Web 服务器、POP 服务器、数据库服务器或文件服务器）代表远程客户机处理请求，这些客户机通常使用 socket 连接到服务器。对于每个请求，通常要进行少量处理（获得该文件的代码块，并将其发送回 socket），但是可能会有大量（且不受限制）的客户机请求服务。</p>
<p> 用于构建服务器应用程序的简单化模型会为每个请求创建新的线程。下列代码段实现简单的 Web 服务器，它接受端口 80 的 socket 连接，并创建新的线程来处理请求。不幸的是，该代码不是实现 Web 服务器的好方法，因为在重负载条件下它将失败，停止整台服务器。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnreliableWebServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line"></span><br><span class="line">      Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          handleRequest(connection);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Don&#x27;t do this!</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Thread(r).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 当服务器被请求吞没时，UnreliableWebServer 类不能很好地处理这种情况。每次有请求时，就会创建新的类。根据操作系统和可用内存，可以创建的线程数是有限的。</p>
<p> 不幸的是，您通常不知道限制是多少 – 只有当应用程序因为 OutOfMemoryError 而崩溃时才发现。</p>
<p> 如果足够快地在这台服务器上抛出请求的话，最终其中一个线程创建将失败，生成的 Error 会关闭整个应用程序。当一次仅能有效支持很少线程时，没有必要创建上千个</p>
<p> 线程，无论如何，这样使用资源可能会损害性能。创建线程会使用相当一部分内存，其中包括有两个堆栈（Java 和 C），以及每线程数据结构。如果创建过多线程，其中</p>
<p> 每个线程都将占用一些 CPU 时间，结果将使用许多内存来支持大量线程，每个线程都运行得很慢。这样就无法很好地使用计算资源。</p>
</li>
<li><p>使用线程池解决问题</p>
<p> 为任务创建新的线程并不一定不好，但是如果创建任务的频率高，而平均任务持续时间低，我们可以看到每项任务创建一个新的线程将产生性能（如果负载不可预知，还有稳定性）问题。</p>
<p> 如果不是每项任务创建一个新的线程，则服务器应用程序必须采取一些方法来限制一次可以处理的请求数。这意味着每次需要启动新的任务时，它不能仅调用下列代码。</p>
<p> new Thread(runnable).start()</p>
<p> 管理一大组小任务的标准机制是组合工作队列和线程池。工作队列就是要处理的任务的队列，前面描述的 Queue 类完全适合。线程池是线程的集合，每个线程都提取公用工作队列。当一个工作线程完成任务处理后，它会返回队列，查看是否有其他任务需要处理。如果有，它会转移到下一个任务，并开始处理。</p>
<p> 线程池为线程生命周期间接成本问题和资源崩溃问题提供了解决方案。通过对多个任务重新使用线程，创建线程的间接成本将分布到多个任务中。作为一种额外好处，因为请求到达时，线程已经存在，从而可以消除由创建线程引起的延迟。因此，可以立即处理请求，使应用程序更易响应。而且，通过正确调整线程池中的线程数，可以强制超出特定限制的任何请求等待，直到有线程可以处理它，它们等待时所消耗的资源要少于使用额外线程所消耗的资源，这样可以防止资源崩溃。</p>
</li>
<li><p>Executor 框架</p>
<p> java.util.concurrent 包中包含灵活的线程池实现，但是更重要的是，它包含用于管理实现 Runnable 的任务的执行的整个框架。该框架称为 Executor 框架。</p>
<p> Executor 接口相当简单。它描述将运行 Runnable 的对象：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 任务运行于哪个线程不是由该接口指定的，这取决于使用的 Executor 的实现。它可以运行于后台线程，如 Swing 事件线程，或者运行于线程池，或者调用线程，或者新的线程，它甚至可以运行于其他 JVM！通过同步的 Executor 接口提交任务，从任务执行策略中删除任务提交。Executor 接口独自关注任务提交 – 这是Executor 实现的选择，确定执行策略。这使在部署时调整执行策略（队列限制、池大小、优先级排列等等）更加容易，更改的代码最少。</p>
<p> java.util.concurrent 中的大多数 Executor 实现还实现 ExecutorService 接口，这是对 Executor 的扩展，它还管理执行服务的生命周期。这使它们更易于管理，并向生命可能比单独 Executor 的生命更长的应用程序提供服务。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// other convenience methods for submitting tasks</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Executor</p>
<p> java.util.concurrent 包包含多个 Executor 实现，每个实现都实现不同的执行策略。什么是执行策略？执行策略定义何时在哪个线程中运行任务，执行任务可能消耗的资源级别（线程、内存等等），以及如果执行程序超载该怎么办。</p>
<p> 执行程序通常通过工厂方法例示，而不是通过构造函数。Executors 类包含用于构造许多不同类型的 Executor 实现的静态工厂方法：</p>
<p> • Executors.newCachedThreadPool() 创建不限制大小的线程池，但是当以前创建的线程可以使用时将重新使用那些线程。如果没有现有线程可用，</p>
<p> • 将创建新的线程并将其添加到池中。使用不到 60 秒的线程将终止并从缓存中删除。</p>
<p> • Executors.newFixedThreadPool(int n) 创建线程池，其重新使用在不受限制的队列之外运行的固定线程组。在关闭前，所有线程都会因为执行</p>
<p> • 过程中的失败而终止，如果需要执行后续任务，将会有新的线程来代替这些线程。</p>
<p> • Executors.newSingleThreadExecutor() 创建 Executor，其使用在不受限制的队列之外运行的单一工作线程，与 Swing 事件线程非常相似。</p>
<p> • 保证顺序执行任务，在任何给定时间，不会有多个任务处于活动状态。</p>
<p> 更可靠的 Web 服务器 – 使用 Executor</p>
<p> 前面 如何不对任务进行管理 中的代码显示了如何不用编写可靠服务器应用程序。幸运的是，修复这个示例非常简单，只需将 Thread.start() 调用替换为向 Executor 提交任务即可：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReliableWebServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Executor pool =</span><br><span class="line"></span><br><span class="line">    Executors.newFixedThreadPool(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line"></span><br><span class="line">      Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          handleRequest(connection);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      pool.execute(r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 注意，本例与前例之间的区别仅在于 Executor 的创建以及如何提交执行的任务。</p>
</li>
</ol>
<ol start="9">
<li>定制 ThreadPoolExecutor</li>
</ol>
<blockquote>
<blockquote>
<p>Executors 中的 newFixedThreadPool 和 newCachedThreadPool 工厂方法返回的 Executor 是类 ThreadPoolExecutor 的实例，是高度可定制的。<br>通过使用包含 ThreadFactory 变量的工厂方法或构造函数的版本，可以定义池线程的创建。ThreadFactory 是工厂对象，其构造执行程序要使用的新线程。<br>使用定制的线程工厂，创建的线程可以包含有用的线程名称，并且这些线程是守护线程，属于特定线程组或具有特定优先级。<br>下面是线程工厂的例子，它创建守护线程，而不是创建用户线程：</p>
</blockquote>
</blockquote>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line"></span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

有时，Executor 不能执行任务，因为它已经关闭或者因为 Executor 使用受限制队列存储等待任务，而该队列已满。在这种情况下，需要咨询执行程序的 RejectedExecutionHandler 来确定如何处理任务 -- 抛出异常（默认情况），放弃任务，在调用者的线程中执行任务，或放弃队列中最早的任务以为新任务腾出空间。ThreadPoolExecutor.setRejectedExecutionHandler 可以设置拒绝的执行处理程序。

还可以扩展 ThreadPoolExecutor，并覆盖方法 beforeExecute 和 afterExecute，以添加装置，添加记录，添加计时，重新初始化线程本地变量，或进行其他执行定制。

 需要特别考虑的问题

    使用 Executor 框架会从执行策略中删除任务提交，一般情况下，人们希望这样，那是因为它允许我们灵活地调整执行策略，不必更改许多位置的代码。然而，当提交代码暗含假设特定执行策略时，存在多种情况，在这些情况下，重要的是选择的 Executor 实现一致的执行策略。

    这类情况中的其中的一种就是一些任务同时等待其他任务完成。在这种情况下，当线程池没有足够的线程时，如果所有当前执行的任务都在等待另一项任务，而该任务因为线程池已满不能执行，那么线程池可能会死锁。

    另一种相似的情况是一组线程必须作为共同操作组一起工作。在这种情况下，需要确保线程池能够容纳所有线程。

    如果应用程序对特定执行程序进行了特定假设，那么应该在 Executor 定义和初始化的附近对这些进行说明，从而使善意的更改不会破坏应用程序的正确功能。

调整线程池

    创建 Executor 时，人们普遍会问的一个问题是&quot;线程池应该有多大？&quot;。当然，答案取决于硬件和将执行的任务类型（它们是受计算限制或是受 IO 的限制？）。

    如果线程池太小，资源可能不能被充分利用，在一些任务还在工作队列中等待执行时，可能会有处理器处于闲置状态。

    另一方面，如果线程池太大，则将有许多有效线程，因为大量线程或有效任务使用内存，或者因为每项任务要比使用少量线程有更多上下文切换，性能可能会受损。

    所以假设为了使处理器得到充分使用，线程池应该有多大？如果知道系统有多少处理器和任务的计算时间和等待时间的近似比率，Amdahl 法则提供很好的近似公式。

    用 WT 表示每项任务的平均等待时间，ST 表示每项任务的平均服务时间（计算时间）。则 WT/ST 是每项任务等待所用时间的百分比。对于 N 处理器系统，池中可以近似有 N*(1+WT/ST) 个线程。

    好的消息是您不必精确估计 WT/ST。&quot;合适的&quot;池大小的范围相当大；只需要避免&quot;过大&quot;和&quot;过小&quot;的极端情况即可。</code></pre>
<ol start="10">
<li><p>Future 接口</p>
<p>Future 接口允许表示已经完成的任务、正在执行过程中的任务或者尚未开始执行的任务。通过 Future 接口，可以尝试取消尚未完成的任务，查询任务已经完成还是取消了，以及提取（或等待）任务的结果值。</p>
<p>FutureTask 类实现了 Future，并包含一些构造函数，允许将 Runnable 或 Callable（会产生结果的 Runnable）和 Future 接口封装。因为 FutureTask 也实现 Runnable，所以可以只将 FutureTask 提供给 Executor。一些提交方法（如 ExecutorService.submit()）除了提交任务之外，还将返回 Future 接口。</p>
<p>Future.get() 方法检索任务计算的结果（或如果任务完成，但有异常，则抛出 ExecutionException）。如果任务尚未完成，那么 Future.get() 将被阻塞，直到任务完成；如果任务已经完成，那么它将立即返回结果。</p>
<p>使用 Future 构建缓存</p>
<pre><code>该示例代码与 java.util.concurrent 中的多个类关联，突出显示了 Future 的功能。它实现缓存，使用 Future 描述缓存值，该值可能已经计算，或者可能在其他线程中&quot;正在构造&quot;。

它利用 ConcurrentHashMap 中的原子 putIfAbsent() 方法，确保仅有一个线程试图计算给定关键字的值。如果其他线程随后请求同一关键字的值，它仅能等待（通过 Future.get() 的帮助）第一个线程完成。因此两个线程不会计算相同的值。</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ConcurrentMap&gt; map = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    Executor executor = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        FutureTask f = map.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            Callable c = <span class="keyword">new</span> Callable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// return value associated with key</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            f = <span class="keyword">new</span> FutureTask(c);</span><br><span class="line"></span><br><span class="line">            FutureTask old = map.putIfAbsent(key, f);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (old == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">                executor.execute(f);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                f = old;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CompletionService</p>
<p>CompletionService 将执行服务与类似 Queue 的接口组合，从任务执行中删除任务结果的处理。CompletionService 接口包含用来提交将要执行的任务的 submit() 方法和用来询问下一完成任务的 take()/poll() 方法。</p>
<p>CompletionService 允许应用程序结构化，使用 Producer/Consumer 模式，其中生产者创建任务并提交，消费者请求完成任务的结果并处理这些结果。CompletionService 接口由 ExecutorCompletionService 类实现，该类使用 Executor 处理任务并从 CompletionService 导出 submit/poll/take 方法。</p>
<p>下列代码使用 Executor 和 CompletionService 来启动许多”solver”任务，并使用第一个生成非空结果的任务的结果，然后取消其余任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Executor e, Collection&gt; solvers)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletionService ecs = <span class="keyword">new</span> ExecutorCompletionService(e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = solvers.size();</span><br><span class="line"></span><br><span class="line">        List&gt; futures = <span class="keyword">new</span> ArrayList&gt;(n);</span><br><span class="line"></span><br><span class="line">        Result result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Callable s : solvers)</span><br><span class="line"></span><br><span class="line">                futures.add(ecs.submit(s));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    Result r = ecs.take().get();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        result = r;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span>(ExecutionException ignore) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Future f : futures)</span><br><span class="line"></span><br><span class="line">                f.cancel(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">            use(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="java-util-concurrent-中其他类别的有用的类也是同步工具。这组类相互协作，控制一个或多个线程的执行流。"><a href="#java-util-concurrent-中其他类别的有用的类也是同步工具。这组类相互协作，控制一个或多个线程的执行流。" class="headerlink" title="java.util.concurrent 中其他类别的有用的类也是同步工具。这组类相互协作，控制一个或多个线程的执行流。"></a>java.util.concurrent 中其他类别的有用的类也是同步工具。这组类相互协作，控制一个或多个线程的执行流。</h2><p>Semaphore、CyclicBarrier、CountdownLatch 和 Exchanger 类都是同步工具的例子。每个类都有线程可以调用的方法，方法是否被阻塞取决于正在使用的特定同步工具的状态和规则。</p>
</li>
<li><p>Semaphore</p>
<p> Semaphore 类实现标准 Dijkstra 计数信号。计数信号可以认为具有一定数量的许可权，该许可权可以获得或释放。如果有剩余的许可权，acquire() 方法将成功，否则该方法将被阻塞，直到有可用的许可权（通过其他线程释放许可权）。线程一次可以获得多个许可权。</p>
<p> 计数信号可以用于限制有权对资源进行并发访问的线程数。该方法对于实现资源池或限制 Web 爬虫（Web crawler）中的输出 socket 连接非常有用。</p>
<p> 注意信号不跟踪哪个线程拥有多少许可权；这由应用程序来决定，以确保何时线程释放许可权，该信号表示其他线程拥有许可权或者正在释放许可权，以及其他线程知道它的许可权已释放。</p>
</li>
<li><p>互斥</p>
<p> 计数信号的一种特殊情况是互斥，或者互斥信号。互斥就是具有单一许可权的计数信号，意味着在给定时间仅一个线程可以具有许可权（也称为二进制信号）。互斥可以用于管理对共享资源的独占访问。</p>
<p> 虽然互斥许多地方与锁定一样，但互斥还有一个锁定通常没有的其他功能，就是互斥可以由具有许可权的线程之外的其他线程来释放。这在死锁恢复时会非常有用。</p>
<p> CyclicBarrier 类可以帮助同步，它允许一组线程等待整个线程组到达公共屏障点。CyclicBarrier 是使用整型变量构造的，其确定组中的线程数。当一个线程到达屏障时（通过调用 CyclicBarrier.await()），它会被阻塞，直到所有线程都到达屏障，然后在该点允许所有线程继续执行。该操作与许多家庭逛商业街相似 – 每个家庭成员都自己走，并商定 1:00 在电影院集合。当您到电影院但不是所有人都到了时，您会坐下来等其他人到达。然后所有人一起离开。</p>
<p> 认为屏障是循环的是因为它可以重新使用；一旦所有线程都已经在屏障处集合并释放，则可以将该屏障重新初始化到它的初始状态。 还可以指定在屏障处等待时的超时；如果在该时间内其余线程还没有到达屏障，则认为屏障被打破，所有正在等待的线程会收到 BrokenBarrierException。</p>
<p> 下列代码将创建 CyclicBarrier 并启动一组线程，每个线程将计算问题的一部分，等待所有其他线程结束之后，再检查解决方案是否达成一致。如果不一致，那么每个工作线程将开始另一个迭代。该例将使用 CyclicBarrier 变量，它允许注册 Runnable，在所有线程到达屏障但还没有释放任何线程时执行 Runnable。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solver</span> </span>&#123; <span class="comment">// Code sketch</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">final</span> Problem p, <span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> CyclicBarrier barrier =</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> CyclicBarrier(nThreads,</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; p.checkConvergence(); &#125;&#125;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; ++i) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> id = i;</span><br><span class="line"></span><br><span class="line">      Runnable worker = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Segment segment = p.createSegment(id);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!p.converged()) &#123;</span><br><span class="line"></span><br><span class="line">              segment.update();</span><br><span class="line"></span><br><span class="line">              barrier.await();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">catch</span>(Exception e) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Thread(worker).start();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CountdownLatch</p>
<p> CountdownLatch 类与 CyclicBarrier 相似，因为它的角色是对已经在它们中间分摊了问题的一组线程进行协调。它也是使用整型变量构造的，指明计数的初始值，但是与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。</p>
<p> 其中，CyclicBarrier 是到达屏障的所有线程的大门，只有当所有线程都已经到达屏障或屏障被打破时，才允许这些线程通过，CountdownLatch 将到达和等待功能分离。任何线程都可以通过调用 countDown() 减少当前计数，这种不会阻塞线程，而只是减少计数。await() 方法的行为与 CyclicBarrier.await() 稍微有所不同，调用 await() 任何线程都会被阻塞，直到闩锁计数减少为零，在该点等待的所有线程才被释放，对 await() 的后续调用将立即返回。</p>
<p> 当问题已经分解为许多部分，每个线程都被分配一部分计算时，CountdownLatch 非常有用。在工作线程结束时，它们将减少计数，协调线程可以在闩锁处等待当前这一批计算结束，然后继续移至下一批计算。</p>
<p> 相反地，具有计数 1 的 CountdownLatch 类可以用作”启动大门”，来立即启动一组线程；工作线程可以在闩锁处等待，协调线程减少计数，从而立即释放所有工作线程。下例使用两个 CountdownLatche。一个作为启动大门，一个在所有工作线程结束时释放线程：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">     CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">     doSomethingElse();            <span class="comment">// don&#x27;t let them run yet</span></span><br><span class="line"></span><br><span class="line">     startSignal.countDown();      <span class="comment">// let all threads proceed</span></span><br><span class="line"></span><br><span class="line">     doSomethingElse();</span><br><span class="line"></span><br><span class="line">     doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        startSignal.await();</span><br><span class="line"></span><br><span class="line">        doWork();</span><br><span class="line"></span><br><span class="line">        doneSignal.countDown();</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Exchanger 类方便了两个共同操作线程之间的双向交换；这样，就像具有计数为 2 的 CyclicBarrier，并且两个线程在都到达屏障时可以”交换”一些状态。（Exchanger 模式有时也称为聚集。）</p>
<p> Exchanger 通常用于一个线程填充缓冲（通过读取 socket），而另一个线程清空缓冲（通过处理从 socket 收到的命令）的情况。当两个线程在屏障处集合时，它们交换缓冲。下列代码说明了这项技术：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FillAndEmpty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   Exchanger exchanger = <span class="keyword">new</span> Exchanger();</span><br><span class="line"></span><br><span class="line">   DataBuffer initialEmptyBuffer = <span class="keyword">new</span> DataBuffer();</span><br><span class="line"></span><br><span class="line">   DataBuffer initialFullBuffer = <span class="keyword">new</span> DataBuffer();</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">FillingLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       DataBuffer currentBuffer = initialEmptyBuffer;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span> (currentBuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">           addToBuffer(currentBuffer);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (currentBuffer.full())</span><br><span class="line"></span><br><span class="line">             currentBuffer = exchanger.exchange(currentBuffer);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ... &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">EmptyingLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       DataBuffer currentBuffer = initialFullBuffer;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span> (currentBuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">           takeFromBuffer(currentBuffer);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (currentBuffer.empty())</span><br><span class="line"></span><br><span class="line">             currentBuffer = exchanger.exchange(currentBuffer);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> Thread(<span class="keyword">new</span> FillingLoop()).start();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> Thread(<span class="keyword">new</span> EmptyingLoop()).start();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>锁定和原子之Lock</p>
<p> Java 语言内置了锁定工具 – synchronized 关键字。当线程获得监视器时（内置锁定），其他线程如果试图获得相同锁定，那么它们将被阻塞，直到第一个线程释放该锁定。同步还确保随后获得相同锁定的线程可以看到之前的线程在具有该锁定时所修改的变量的值，从而确保如果类正确地同步了共享状态的访问权，那么线程将不会看到变量的”失效”值，这是缓存或编译器优化的结果。</p>
<p> 虽然同步没有什么问题，但它有一些限制，在一些高级应用程序中会造成不便。Lock 接口将内置监视器锁定的锁定行为普遍化，允许多个锁定实现，同时提供一些内置锁定缺少的功能，如计时的等待、可中断的等待、锁定轮询、每个锁定有多个条件等待集合以及无阻塞结构的锁定。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> IE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                    TimeUnit unit)</span> <span class="keyword">throws</span> IE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                    UnsupportedOperationException</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ReentrantLock</p>
<p> ReentrantLock 是具有与隐式监视器锁定（使用 synchronized 方法和语句访问）相同的基本行为和语义的 Lock 的实现，但它具有扩展的能力。</p>
<p> 作为额外收获，在竞争条件下，ReentrantLock 的实现要比现在的 synchronized 实现更具有可伸缩性。（有可能在 JVM 的将来版本中改进 synchronized 的竞争性能。）</p>
<p> 这意味着当许多线程都竞争相同锁定时，使用 ReentrantLock 的吞吐量通常要比 synchronized 好。换句话说，当许多线程试图访问 ReentrantLock 保护的共享资源时，JVM 将花费较少的时间来调度线程，而用更多个时间执行线程。</p>
<p> 虽然 ReentrantLock 类有许多优点，但是与同步相比，它有一个主要缺点 – 它可能忘记释放锁定。建议当获得和释放 ReentrantLock 时使用下列结构：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// perform operations protected by lock</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// restore invariants</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">  lock.unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 因为锁定失误（忘记释放锁定）的风险，所以对于基本锁定，强烈建议您继续使用 synchronized，除非真的需要 ReentrantLock 额外的灵活性和可伸缩性。</p>
<p> ReentrantLock 是用于高级应用程序的高级工具 – 有时需要，但有时用原来的方法就很好。</p>
</li>
<li><p>Condition</p>
<p> 就像 Lock 接口是同步的具体化，Condition 接口是 Object 中 wait() 和 notify() 方法的具体化。Lock 中的一个方法是 newCondition()，它要求锁定向该锁定返回新的 Condition 对象限制。await()、signal() 和 signalAll() 方法类似于 wait()、notify() 和 notifyAll()，但增加了灵活性，每个 Lock 都可以创建多个条件变量。这简化了一些并发算法的实现。</p>
</li>
<li><p>ReadWriteLock</p>
<p> ReentrantLock 实现的锁定规则非常简单 – 每当一个线程具有锁定时，其他线程必须等待，直到该锁定可用。有时，当对数据结构的读取通常多于修改时，可以使用更复杂的称为读写锁定的锁定结构，它允许有多个并发读者，同时还允许一个写入者独占锁定。该方法在一般情况下（只读）提供了更大的并发性，同时在必要时仍提供独占访问的安全性。ReadWriteLock 接口和 ReentrantReadWriteLock 类提供这种功能 – 多读者、单写入者锁定规则，可以用这种功能来保护共享的易变资源。</p>
</li>
<li><p>原子变量</p>
<p> 即使大多数用户将很少直接使用它们，原子变量类（AtomicInteger、AtomicLong、AtomicReference 等等）也有充分理由是最显著的新并发类。这些类公开对 JVM 的低级别改进，允许进行具有高度可伸缩性的原子读-修改-写操作。大多数现代 CPU 都有原子读-修改-写的原语，比如比较并交换（CAS）或加载链接/条件存储（LL/SC）。原子变量类使用硬件提供的最快的并发结构来实现。</p>
<p> 许多并发算法都是根据对计数器或数据结构的比较并交换操作来定义的。通过暴露高性能的、高度可伸缩的 CAS 操作（以原子变量的形式），用 Java 语言实现高性能、无等待、无锁定的并发算法已经变得可行。</p>
<p> 几乎 java.util.concurrent 中的所有类都是在 ReentrantLock 之上构建的，ReentrantLock 则是在原子变量类的基础上构建的。所以，虽然仅少数并发专家使用原子变量类，但 java.util.concurrent 类的很多可伸缩性改进都是由它们提供的。</p>
<p> 原子变量主要用于为原子地更新”热”字段提供有效的、细粒度的方式，”热”字段是指由多个线程频繁访问和更新的字段。另外，原子变量还是计数器或生成序号的自然机制。</p>
</li>
<li><p>性能与可伸缩性</p>
<p>虽然 java.util.concurrent 努力的首要目标是使编写正确、线程安全的类更加容易，但它还有一个次要目标，就是提供可伸缩性。可伸缩性与性能完全不同，实际上，可伸缩性有时要以性能为代价来获得。</p>
<p>性能是”可以快速执行此任务的程度”的评测。可伸缩性描述应用程序的吞吐量如何表现为它的工作量和可用计算资源增加。可伸缩的程序可以按比例使用更多的处理器、内存或 I/O 带宽来处理更多个工作量。当我们在并发环境中谈论可伸缩性时，我们是在问当许多线程同时访问给定类时，这个类的执行情况。</p>
<p>java.util.concurrent 中的低级别类 ReentrantLock 和原子变量类的可伸缩性要比内置监视器（同步）锁定高得多。因此，使用 ReentrantLock 或原子变量类来协调共享访问的类也可能更具有可伸缩性。</p>
</li>
<li><p>Hashtable 与 ConcurrentHashMap</p>
<p>作为可伸缩性的例子，ConcurrentHashMap 实现设计的可伸缩性要比其线程安全的上一代 Hashtable 的可伸缩性强得多。Hashtable 一次只允许一个线程访问 Map；ConcurrentHashMap 允许多个读者并发执行，读者与写入者并发执行，以及一些写入者并发执行。因此，如果许多线程频繁访问共享映射，使用 ConcurrentHashMap 的总的吞吐量要比使用 Hashtable 的好。</p>
<p>下表大致说明了 Hashtable 和 ConcurrentHashMap 之间的可伸缩性差别。在每次运行时，N 个线程并发执行紧密循环，它们从 Hashtable 或 ConcurrentHashMap 中检索随即关键字，60% 的失败检索将执行 put() 操作，2% 的成功检索执行 remove() 操作。测试在运行 Linux 的双处理器 Xeon 系统中执行。数据显示 10,000,000 个迭代的运行时间，对于 ConcurrentHashMap，标准化为一个线程的情况。可以看到直到许多线程，ConcurrentHashMap 的性能仍保持可伸缩性，而 Hashtable 的性能在出现锁定竞争时几乎立即下降。</p>
<p>与通常的服务器应用程序相比，这个测试中的线程数看起来很少。然而，因为每个线程未进行其他操作，仅是重复地选择使用该表，所以这样可以模拟在执行一些实际工作的情况下使用该表的大量线程的竞争。</p>
<table>
<thead>
<tr>
<th align="center">线程</th>
<th align="center">ConcurrentHashMap</th>
<th align="center">Hashtable</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1.0</td>
<td align="center">1.51</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1.44</td>
<td align="center">17.09</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">1.83</td>
<td align="center">29.9</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">4.06</td>
<td align="center">54.06</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">7.5</td>
<td align="center">119.44</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">15.32</td>
<td align="center">237.2</td>
</tr>
</tbody></table>
</li>
<li><p>Lock 与 synchronized 与原子</p>
<p>下列基准说明了使用 java.util.concurrent 可能改进可伸缩性的例子。该基准将模拟旋转骰子，使用线性同余随机数生成器。有三个可用的随机数生成器的实现：一个使用同步来管理生成器的状态（单一变量），一个使用 ReentrantLock，另一个则使用 AtomicLong。下图显示了在 8-way Ultrasparc3 系统上，逐渐增加线程数量时这三个版本的相对吞吐量。（该图对原子变量方法的可伸缩性描述比较保守。）</p>
</li>
</ol>
<ol start="13">
<li><p>公平与不公平</p>
<p>java.util.concurrent 中许多类中的另外一个定制元素是”公平”的问题。公平锁定或公平信号是指在其中根据先进先出（FIFO）的原则给与线程锁定或信号。ReentrantLock、Semaphore 和 ReentrantReadWriteLock 的构造函数都可以使用变量确定锁定是否公平，或者是否允许闯入（线程获得锁定，即使它们等待的时间不是最长）。</p>
<p>虽然闯入锁定的想法可能有些可笑，但实际上不公平、闯入的锁定非常普遍，且通常很受欢迎。使用同步访问的内置锁定不是公平锁定（且没有办法使它们公平）。相反，它们提供较弱的生病保证，要求所有线程最终都将获得锁定。</p>
<p>大多数应用程序选择（且应该选择）闯入锁定而不是公平锁定的原因是性能。在大多数情况下，完全的公平不是程序正确性的要求，真正公平的成本相当高。下表向前面的面板中的表中添加了第四个数据集，并由一个公平锁定管理对 PRNG 状态的访问。注意闯入锁定与公平锁定之间吞吐量的巨大差别。</p>
</li>
</ol>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><pre><code>java.util.concurrent 包中包含大量有用的构建快，可以用它们来改进并发类的性能、可伸缩性、线程安全和可维护性。通过这些构建快，应该可以不再需要在您的代码中大量使用同步、wait/notify 和 Thread.start()，而用更高级别、标准化的、高性能并发实用程序来替换它们。

Exchanger,CyclicBarrier,Synchronizer</code></pre>
<hr>
<p>本文由 blog博主Caoer（草儿）原创，此处为转载。</p>
<p>由于原文两张图片不方便显示,这里暂时去掉，转载时本博(<a target="_blank" rel="noopener" href="http://www.blogjava.net/mlh123caoer/archive/2007/10/24/155474.html)%E9%87%8D%E6%96%B0%E5%BC%95%E7%94%A8%E4%BA%86%E5%9B%BE%E7%89%87%EF%BC%8C%E5%B9%B6%E8%B0%83%E6%95%B4%E4%BA%86%E7%89%88%E9%9D%A2%E3%80%82">http://www.blogjava.net/mlh123caoer/archive/2007/10/24/155474.html)重新引用了图片，并调整了版面。</a></p>
<p>如原创作者认为本文侵权，请通知本博。</p>
<blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/index.html">并发参考学习</a></p>
</blockquote>
</blockquote>


        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/java/">java</a>
                
                    <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
                
                    <a href="/tags/%E5%B9%B6%E5%8F%91/">并发</a>
                
            </div>
        
    </section>
</article>

    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
    <section class="meta">
        
            <h2 class="title">
                <a href="/2015/09/12/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BExecutorService/">
                    Java thread 多线程 ExecutorService
                </a>
            </h2>
        
        <time>
            9月 12, 2015
        </time>
        
    
    <div class='cats'>
        <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
    </div>

    </section>
    <section class="article typo">
        

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/java/">java</a>
                
                    <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
                
            </div>
        
    </section>
</article>

    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
    <section class="meta">
        
            <h2 class="title">
                <a href="/2015/09/12/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BExecutors/">
                    多线程 Executors
                </a>
            </h2>
        
        <time>
            9月 12, 2015
        </time>
        
    
    <div class='cats'>
        <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
    </div>

    </section>
    <section class="article typo">
        

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/java/">java</a>
                
                    <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
                
            </div>
        
    </section>
</article>

    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
    <section class="meta">
        
            <h2 class="title">
                <a href="/2015/09/12/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadPoolExecutor/">
                    ThreadPoolExecutor 源码分析
                </a>
            </h2>
        
        <time>
            9月 12, 2015
        </time>
        
    
    <div class='cats'>
        <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
    </div>

    </section>
    <section class="article typo">
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Written by Doug Lea with assistance from members of JCP JSR-166</span></span><br><span class="line"><span class="comment"> * Expert Group and released to the public domain, as explained at</span></span><br><span class="line"><span class="comment"> * http://creativecommons.org/publicdomain/zero/1.0/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *一个ExecutorService执行每个被提交入到线程池中的任务，通过Executors工厂方法进行配置。</span></span><br><span class="line"><span class="comment"> *线程池处理两种不同的问题：通过减少每个任务调用的开销、提供边界和资源管理，包括线程，</span></span><br><span class="line"><span class="comment"> *任务集合的执行，从而改进了执行大量异步任务时的性能问题。ThreadPoolExcecutor也维护着一</span></span><br><span class="line"><span class="comment"> *些统计数据，如已完成任务的数目。</span></span><br><span class="line"><span class="comment"> *面对一个提供了许多可调用参数和可扩展性的hooks.程序员通常比较喜欢用Executors的工厂方法。</span></span><br><span class="line"><span class="comment"> *如Executors.newCachedThreadPool(无限大小的线程池，自动线程回收)、Executors.newFixedThreadPool</span></span><br><span class="line"><span class="comment"> *(固定大小的线程池)、Executors.newSingleThreadExecutor(单个后台线程)，为最常用的场</span></span><br><span class="line"><span class="comment"> *景进行预配置。或者，使用这个类进行手动配置实现同样的效果的线程池，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 核心和最大的线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ThreadPoolExecutor会根据线程池的大小配置corePoolSize和maximumPoolSize来自动调整池的大小，</span></span><br><span class="line"><span class="comment"> *可以通过getPoolSize查看池的大小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When a new task is submitted in method &#123;<span class="doctag">@link</span> #execute(Runnable)&#125;,</span></span><br><span class="line"><span class="comment"> * and fewer than corePoolSize threads are running, a new thread is</span></span><br><span class="line"><span class="comment"> * created to handle the request, even if other worker threads are</span></span><br><span class="line"><span class="comment"> * idle.  If there are more than corePoolSize but less than</span></span><br><span class="line"><span class="comment"> * maximumPoolSize threads running, a new thread will be created only</span></span><br><span class="line"><span class="comment"> * if the queue is full.  By setting corePoolSize and maximumPoolSize</span></span><br><span class="line"><span class="comment"> * the same, you create a fixed-size thread pool. By setting</span></span><br><span class="line"><span class="comment"> * maximumPoolSize to an essentially unbounded value such as &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * Integer.MAX_VALUE&#125;, you allow the pool to accommodate an arbitrary</span></span><br><span class="line"><span class="comment"> * number of concurrent tasks. Most typically, core and maximum pool</span></span><br><span class="line"><span class="comment"> * sizes are set only upon construction, but they may also be changed</span></span><br><span class="line"><span class="comment"> * dynamically using &#123;<span class="doctag">@link</span> #setCorePoolSize&#125; and &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #setMaximumPoolSize&#125;. &lt;/dd&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dt&gt;On-demand construction&lt;/dt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dd&gt;By default, even core threads are initially created and</span></span><br><span class="line"><span class="comment"> * started only when new tasks arrive, but this can be overridden</span></span><br><span class="line"><span class="comment"> * dynamically using method &#123;<span class="doctag">@link</span> #prestartCoreThread&#125; or &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #prestartAllCoreThreads&#125;.  You probably want to prestart threads if</span></span><br><span class="line"><span class="comment"> * you construct the pool with a non-empty queue. &lt;/dd&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dt&gt;Creating new threads&lt;/dt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dd&gt;New threads are created using a &#123;<span class="doctag">@link</span> ThreadFactory&#125;.  If not</span></span><br><span class="line"><span class="comment"> * otherwise specified, a &#123;<span class="doctag">@link</span> Executors#defaultThreadFactory&#125; is</span></span><br><span class="line"><span class="comment"> * used, that creates threads to all be in the same &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * ThreadGroup&#125; and with the same &#123;<span class="doctag">@code</span> NORM_PRIORITY&#125; priority and</span></span><br><span class="line"><span class="comment"> * non-daemon status. By supplying a different ThreadFactory, you can</span></span><br><span class="line"><span class="comment"> * alter the thread&#x27;s name, thread group, priority, daemon status,</span></span><br><span class="line"><span class="comment"> * etc. If a &#123;<span class="doctag">@code</span> ThreadFactory&#125; fails to create a thread when asked</span></span><br><span class="line"><span class="comment"> * by returning null from &#123;<span class="doctag">@code</span> newThread&#125;, the executor will</span></span><br><span class="line"><span class="comment"> * continue, but might not be able to execute any tasks. Threads</span></span><br><span class="line"><span class="comment"> * should possess the &quot;modifyThread&quot; &#123;<span class="doctag">@code</span> RuntimePermission&#125;. If</span></span><br><span class="line"><span class="comment"> * worker threads or other threads using the pool do not possess this</span></span><br><span class="line"><span class="comment"> * permission, service may be degraded: configuration changes may not</span></span><br><span class="line"><span class="comment"> * take effect in a timely manner, and a shutdown pool may remain in a</span></span><br><span class="line"><span class="comment"> * state in which termination is possible but not completed.&lt;/dd&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dt&gt;Keep-alive times&lt;/dt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dd&gt;If the pool currently has more than corePoolSize threads,</span></span><br><span class="line"><span class="comment"> * excess threads will be terminated if they have been idle for more</span></span><br><span class="line"><span class="comment"> * than the keepAliveTime (see &#123;<span class="doctag">@link</span> #getKeepAliveTime(TimeUnit)&#125;).</span></span><br><span class="line"><span class="comment"> * This provides a means of reducing resource consumption when the</span></span><br><span class="line"><span class="comment"> * pool is not being actively used. If the pool becomes more active</span></span><br><span class="line"><span class="comment"> * later, new threads will be constructed. This parameter can also be</span></span><br><span class="line"><span class="comment"> * changed dynamically using method &#123;<span class="doctag">@link</span> #setKeepAliveTime(long,</span></span><br><span class="line"><span class="comment"> * TimeUnit)&#125;.  Using a value of &#123;<span class="doctag">@code</span> Long.MAX_VALUE&#125; &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * TimeUnit#NANOSECONDS&#125; effectively disables idle threads from ever</span></span><br><span class="line"><span class="comment"> * terminating prior to shut down. By default, the keep-alive policy</span></span><br><span class="line"><span class="comment"> * applies only when there are more than corePoolSize threads. But</span></span><br><span class="line"><span class="comment"> * method &#123;<span class="doctag">@link</span> #allowCoreThreadTimeOut(boolean)&#125; can be used to</span></span><br><span class="line"><span class="comment"> * apply this time-out policy to core threads as well, so long as the</span></span><br><span class="line"><span class="comment"> * keepAliveTime value is non-zero. &lt;/dd&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dt&gt;Queuing&lt;/dt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dd&gt;Any &#123;<span class="doctag">@link</span> BlockingQueue&#125; may be used to transfer and hold</span></span><br><span class="line"><span class="comment"> * submitted tasks.  The use of this queue interacts with pool sizing:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; If fewer than corePoolSize threads are running, the Executor</span></span><br><span class="line"><span class="comment"> * always prefers adding a new thread</span></span><br><span class="line"><span class="comment"> * rather than queuing.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; If corePoolSize or more threads are running, the Executor</span></span><br><span class="line"><span class="comment"> * always prefers queuing a request rather than adding a new</span></span><br><span class="line"><span class="comment"> * thread.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; If a request cannot be queued, a new thread is created unless</span></span><br><span class="line"><span class="comment"> * this would exceed maximumPoolSize, in which case, the task will be</span></span><br><span class="line"><span class="comment"> * rejected.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are three general strategies for queuing:</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; &lt;em&gt; Direct handoffs.&lt;/em&gt; A good default choice for a work</span></span><br><span class="line"><span class="comment"> * queue is a &#123;<span class="doctag">@link</span> SynchronousQueue&#125; that hands off tasks to threads</span></span><br><span class="line"><span class="comment"> * without otherwise holding them. Here, an attempt to queue a task</span></span><br><span class="line"><span class="comment"> * will fail if no threads are immediately available to run it, so a</span></span><br><span class="line"><span class="comment"> * new thread will be constructed. This policy avoids lockups when</span></span><br><span class="line"><span class="comment"> * handling sets of requests that might have internal dependencies.</span></span><br><span class="line"><span class="comment"> * Direct handoffs generally require unbounded maximumPoolSizes to</span></span><br><span class="line"><span class="comment"> * avoid rejection of new submitted tasks. This in turn admits the</span></span><br><span class="line"><span class="comment"> * possibility of unbounded thread growth when commands continue to</span></span><br><span class="line"><span class="comment"> * arrive on average faster than they can be processed.  &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&lt;em&gt; Unbounded queues.&lt;/em&gt; Using an unbounded queue (for</span></span><br><span class="line"><span class="comment"> * example a &#123;<span class="doctag">@link</span> LinkedBlockingQueue&#125; without a predefined</span></span><br><span class="line"><span class="comment"> * capacity) will cause new tasks to wait in the queue when all</span></span><br><span class="line"><span class="comment"> * corePoolSize threads are busy. Thus, no more than corePoolSize</span></span><br><span class="line"><span class="comment"> * threads will ever be created. (And the value of the maximumPoolSize</span></span><br><span class="line"><span class="comment"> * therefore doesn&#x27;t have any effect.)  This may be appropriate when</span></span><br><span class="line"><span class="comment"> * each task is completely independent of others, so tasks cannot</span></span><br><span class="line"><span class="comment"> * affect each others execution; for example, in a web page server.</span></span><br><span class="line"><span class="comment"> * While this style of queuing can be useful in smoothing out</span></span><br><span class="line"><span class="comment"> * transient bursts of requests, it admits the possibility of</span></span><br><span class="line"><span class="comment"> * unbounded work queue growth when commands continue to arrive on</span></span><br><span class="line"><span class="comment"> * average faster than they can be processed.  &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&lt;em&gt;Bounded queues.&lt;/em&gt; A bounded queue (for example, an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ArrayBlockingQueue&#125;) helps prevent resource exhaustion when</span></span><br><span class="line"><span class="comment"> * used with finite maximumPoolSizes, but can be more difficult to</span></span><br><span class="line"><span class="comment"> * tune and control.  Queue sizes and maximum pool sizes may be traded</span></span><br><span class="line"><span class="comment"> * off for each other: Using large queues and small pools minimizes</span></span><br><span class="line"><span class="comment"> * CPU usage, OS resources, and context-switching overhead, but can</span></span><br><span class="line"><span class="comment"> * lead to artificially low throughput.  If tasks frequently block (for</span></span><br><span class="line"><span class="comment"> * example if they are I/O bound), a system may be able to schedule</span></span><br><span class="line"><span class="comment"> * time for more threads than you otherwise allow. Use of small queues</span></span><br><span class="line"><span class="comment"> * generally requires larger pool sizes, which keeps CPUs busier but</span></span><br><span class="line"><span class="comment"> * may encounter unacceptable scheduling overhead, which also</span></span><br><span class="line"><span class="comment"> * decreases throughput.  &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/dd&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dt&gt;Rejected tasks&lt;/dt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dd&gt;New tasks submitted in method &#123;<span class="doctag">@link</span> #execute(Runnable)&#125; will be</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;rejected&lt;/em&gt; when the Executor has been shut down, and also when</span></span><br><span class="line"><span class="comment"> * the Executor uses finite bounds for both maximum threads and work queue</span></span><br><span class="line"><span class="comment"> * capacity, and is saturated.  In either case, the &#123;<span class="doctag">@code</span> execute&#125; method</span></span><br><span class="line"><span class="comment"> * invokes the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * RejectedExecutionHandler#rejectedExecution(Runnable, ThreadPoolExecutor)&#125;</span></span><br><span class="line"><span class="comment"> * method of its &#123;<span class="doctag">@link</span> RejectedExecutionHandler&#125;.  Four predefined handler</span></span><br><span class="line"><span class="comment"> * policies are provided:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; In the default &#123;<span class="doctag">@link</span> ThreadPoolExecutor.AbortPolicy&#125;, the</span></span><br><span class="line"><span class="comment"> * handler throws a runtime &#123;<span class="doctag">@link</span> RejectedExecutionException&#125; upon</span></span><br><span class="line"><span class="comment"> * rejection. &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; In &#123;<span class="doctag">@link</span> ThreadPoolExecutor.CallerRunsPolicy&#125;, the thread</span></span><br><span class="line"><span class="comment"> * that invokes &#123;<span class="doctag">@code</span> execute&#125; itself runs the task. This provides a</span></span><br><span class="line"><span class="comment"> * simple feedback control mechanism that will slow down the rate that</span></span><br><span class="line"><span class="comment"> * new tasks are submitted. &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; In &#123;<span class="doctag">@link</span> ThreadPoolExecutor.DiscardPolicy&#125;, a task that</span></span><br><span class="line"><span class="comment"> * cannot be executed is simply dropped.  &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;In &#123;<span class="doctag">@link</span> ThreadPoolExecutor.DiscardOldestPolicy&#125;, if the</span></span><br><span class="line"><span class="comment"> * executor is not shut down, the task at the head of the work queue</span></span><br><span class="line"><span class="comment"> * is dropped, and then execution is retried (which can fail again,</span></span><br><span class="line"><span class="comment"> * causing this to be repeated.) &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is possible to define and use other kinds of &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * RejectedExecutionHandler&#125; classes. Doing so requires some care</span></span><br><span class="line"><span class="comment"> * especially when policies are designed to work only under particular</span></span><br><span class="line"><span class="comment"> * capacity or queuing policies. &lt;/dd&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dt&gt;Hook methods&lt;/dt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dd&gt;This class provides &#123;<span class="doctag">@code</span> protected&#125; overridable</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #beforeExecute(Thread, Runnable)&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #afterExecute(Runnable, Throwable)&#125; methods that are called</span></span><br><span class="line"><span class="comment"> * before and after execution of each task.  These can be used to</span></span><br><span class="line"><span class="comment"> * manipulate the execution environment; for example, reinitializing</span></span><br><span class="line"><span class="comment"> * ThreadLocals, gathering statistics, or adding log entries.</span></span><br><span class="line"><span class="comment"> * Additionally, method &#123;<span class="doctag">@link</span> #terminated&#125; can be overridden to perform</span></span><br><span class="line"><span class="comment"> * any special processing that needs to be done once the Executor has</span></span><br><span class="line"><span class="comment"> * fully terminated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If hook or callback methods throw exceptions, internal worker</span></span><br><span class="line"><span class="comment"> * threads may in turn fail and abruptly terminate.&lt;/dd&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dt&gt;Queue maintenance&lt;/dt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dd&gt;Method &#123;<span class="doctag">@link</span> #getQueue()&#125; allows access to the work queue</span></span><br><span class="line"><span class="comment"> * for purposes of monitoring and debugging.  Use of this method for</span></span><br><span class="line"><span class="comment"> * any other purpose is strongly discouraged.  Two supplied methods,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #remove(Runnable)&#125; and &#123;<span class="doctag">@link</span> #purge&#125; are available to</span></span><br><span class="line"><span class="comment"> * assist in storage reclamation when large numbers of queued tasks</span></span><br><span class="line"><span class="comment"> * become cancelled.&lt;/dd&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dt&gt;Finalization&lt;/dt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;dd&gt;A pool that is no longer referenced in a program &lt;em&gt;AND&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * has no remaining threads will be &#123;<span class="doctag">@code</span> shutdown&#125; automatically. If</span></span><br><span class="line"><span class="comment"> * you would like to ensure that unreferenced pools are reclaimed even</span></span><br><span class="line"><span class="comment"> * if users forget to call &#123;<span class="doctag">@link</span> #shutdown&#125;, then you must arrange</span></span><br><span class="line"><span class="comment"> * that unused threads eventually die, by setting appropriate</span></span><br><span class="line"><span class="comment"> * keep-alive times, using a lower bound of zero core threads and/or</span></span><br><span class="line"><span class="comment"> * setting &#123;<span class="doctag">@link</span> #allowCoreThreadTimeOut(boolean)&#125;.  &lt;/dd&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/dl&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Extension example&lt;/b&gt;. Most extensions of this class</span></span><br><span class="line"><span class="comment"> * override one or more of the protected hook methods. For example,</span></span><br><span class="line"><span class="comment"> * here is a subclass that adds a simple pause/resume feature:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * class PausableThreadPoolExecutor extends ThreadPoolExecutor &#123;</span></span><br><span class="line"><span class="comment"> *   private boolean isPaused;</span></span><br><span class="line"><span class="comment"> *   private ReentrantLock pauseLock = new ReentrantLock();</span></span><br><span class="line"><span class="comment"> *   private Condition unpaused = pauseLock.newCondition();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   public PausableThreadPoolExecutor(...) &#123; super(...); &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   protected void beforeExecute(Thread t, Runnable r) &#123;</span></span><br><span class="line"><span class="comment"> *     super.beforeExecute(t, r);</span></span><br><span class="line"><span class="comment"> *     pauseLock.lock();</span></span><br><span class="line"><span class="comment"> *     try &#123;</span></span><br><span class="line"><span class="comment"> *       while (isPaused) unpaused.await();</span></span><br><span class="line"><span class="comment"> *     &#125; catch (InterruptedException ie) &#123;</span></span><br><span class="line"><span class="comment"> *       t.interrupt();</span></span><br><span class="line"><span class="comment"> *     &#125; finally &#123;</span></span><br><span class="line"><span class="comment"> *       pauseLock.unlock();</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   public void pause() &#123;</span></span><br><span class="line"><span class="comment"> *     pauseLock.lock();</span></span><br><span class="line"><span class="comment"> *     try &#123;</span></span><br><span class="line"><span class="comment"> *       isPaused = true;</span></span><br><span class="line"><span class="comment"> *     &#125; finally &#123;</span></span><br><span class="line"><span class="comment"> *       pauseLock.unlock();</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   public void resume() &#123;</span></span><br><span class="line"><span class="comment"> *     pauseLock.lock();</span></span><br><span class="line"><span class="comment"> *     try &#123;</span></span><br><span class="line"><span class="comment"> *       isPaused = false;</span></span><br><span class="line"><span class="comment"> *       unpaused.signalAll();</span></span><br><span class="line"><span class="comment"> *     &#125; finally &#123;</span></span><br><span class="line"><span class="comment"> *       pauseLock.unlock();</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main pool control state, ctl, is an atomic integer packing</span></span><br><span class="line"><span class="comment">     * two conceptual fields</span></span><br><span class="line"><span class="comment">     *   workerCount, indicating the effective number of threads</span></span><br><span class="line"><span class="comment">     *   runState,    indicating whether running, shutting down etc</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In order to pack them into one int, we limit workerCount to</span></span><br><span class="line"><span class="comment">     * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2</span></span><br><span class="line"><span class="comment">     * billion) otherwise representable. If this is ever an issue in</span></span><br><span class="line"><span class="comment">     * the future, the variable can be changed to be an AtomicLong,</span></span><br><span class="line"><span class="comment">     * and the shift/mask constants below adjusted. But until the need</span></span><br><span class="line"><span class="comment">     * arises, this code is a bit faster and simpler using an int.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The workerCount is the number of workers that have been</span></span><br><span class="line"><span class="comment">     * permitted to start and not permitted to stop.  The value may be</span></span><br><span class="line"><span class="comment">     * transiently different from the actual number of live threads,</span></span><br><span class="line"><span class="comment">     * for example when a ThreadFactory fails to create a thread when</span></span><br><span class="line"><span class="comment">     * asked, and when exiting threads are still performing</span></span><br><span class="line"><span class="comment">     * bookkeeping before terminating. The user-visible pool size is</span></span><br><span class="line"><span class="comment">     * reported as the current size of the workers set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The runState provides the main lifecycle control, taking on values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   RUNNING:  Accept new tasks and process queued tasks</span></span><br><span class="line"><span class="comment">     *   SHUTDOWN: Don&#x27;t accept new tasks, but process queued tasks</span></span><br><span class="line"><span class="comment">     *   STOP:     Don&#x27;t accept new tasks, don&#x27;t process queued tasks,</span></span><br><span class="line"><span class="comment">     *             and interrupt in-progress tasks</span></span><br><span class="line"><span class="comment">     *   TIDYING:  All tasks have terminated, workerCount is zero,</span></span><br><span class="line"><span class="comment">     *             the thread transitioning to state TIDYING</span></span><br><span class="line"><span class="comment">     *             will run the terminated() hook method</span></span><br><span class="line"><span class="comment">     *   TERMINATED: terminated() has completed</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The numerical order among these values matters, to allow</span></span><br><span class="line"><span class="comment">     * ordered comparisons. The runState monotonically increases over</span></span><br><span class="line"><span class="comment">     * time, but need not hit each state. The transitions are:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * RUNNING -&gt; SHUTDOWN</span></span><br><span class="line"><span class="comment">     *    On invocation of shutdown(), perhaps implicitly in finalize()</span></span><br><span class="line"><span class="comment">     * (RUNNING or SHUTDOWN) -&gt; STOP</span></span><br><span class="line"><span class="comment">     *    On invocation of shutdownNow()</span></span><br><span class="line"><span class="comment">     * SHUTDOWN -&gt; TIDYING</span></span><br><span class="line"><span class="comment">     *    When both queue and pool are empty</span></span><br><span class="line"><span class="comment">     * STOP -&gt; TIDYING</span></span><br><span class="line"><span class="comment">     *    When pool is empty</span></span><br><span class="line"><span class="comment">     * TIDYING -&gt; TERMINATED</span></span><br><span class="line"><span class="comment">     *    When the terminated() hook method has completed</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Threads waiting in awaitTermination() will return when the</span></span><br><span class="line"><span class="comment">     * state reaches TERMINATED.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Detecting the transition from SHUTDOWN to TIDYING is less</span></span><br><span class="line"><span class="comment">     * straightforward than you&#x27;d like because the queue may become</span></span><br><span class="line"><span class="comment">     * empty after non-empty and vice versa during SHUTDOWN state, but</span></span><br><span class="line"><span class="comment">     * we can only terminate if, after seeing that it is empty, we see</span></span><br><span class="line"><span class="comment">     * that workerCount is 0 (which sometimes entails a recheck -- see</span></span><br><span class="line"><span class="comment">     * below).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Packing and unpacking ctl</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Bit field accessors that don&#x27;t require unpacking ctl.</span></span><br><span class="line"><span class="comment">     * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to CAS-increment the workerCount field of ctl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to CAS-decrement the workerCount field of ctl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decrements the workerCount field of ctl. This is called only on</span></span><br><span class="line"><span class="comment">     * abrupt termination of a thread (see processWorkerExit). Other</span></span><br><span class="line"><span class="comment">     * decrements are performed within getTask.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The queue used for holding tasks and handing off to worker</span></span><br><span class="line"><span class="comment">     * threads.  We do not require that workQueue.poll() returning</span></span><br><span class="line"><span class="comment">     * null necessarily means that workQueue.isEmpty(), so rely</span></span><br><span class="line"><span class="comment">     * solely on isEmpty to see if the queue is empty (which we must</span></span><br><span class="line"><span class="comment">     * do for example when deciding whether to transition from</span></span><br><span class="line"><span class="comment">     * SHUTDOWN to TIDYING).  This accommodates special-purpose</span></span><br><span class="line"><span class="comment">     * queues such as DelayQueues for which poll() is allowed to</span></span><br><span class="line"><span class="comment">     * return null even if it may later return non-null when delays</span></span><br><span class="line"><span class="comment">     * expire.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lock held on access to workers set and related bookkeeping.</span></span><br><span class="line"><span class="comment">     * While we could use a concurrent set of some sort, it turns out</span></span><br><span class="line"><span class="comment">     * to be generally preferable to use a lock. Among the reasons is</span></span><br><span class="line"><span class="comment">     * that this serializes interruptIdleWorkers, which avoids</span></span><br><span class="line"><span class="comment">     * unnecessary interrupt storms, especially during shutdown.</span></span><br><span class="line"><span class="comment">     * Otherwise exiting threads would concurrently interrupt those</span></span><br><span class="line"><span class="comment">     * that have not yet interrupted. It also simplifies some of the</span></span><br><span class="line"><span class="comment">     * associated statistics bookkeeping of largestPoolSize etc. We</span></span><br><span class="line"><span class="comment">     * also hold mainLock on shutdown and shutdownNow, for the sake of</span></span><br><span class="line"><span class="comment">     * ensuring workers set is stable while separately checking</span></span><br><span class="line"><span class="comment">     * permission to interrupt and actually interrupting.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set containing all worker threads in pool. Accessed only when</span></span><br><span class="line"><span class="comment">     * holding mainLock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wait condition to support awaitTermination</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tracks largest attained pool size. Accessed only under</span></span><br><span class="line"><span class="comment">     * mainLock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Counter for completed tasks. Updated only on termination of</span></span><br><span class="line"><span class="comment">     * worker threads. Accessed only under mainLock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * All user control parameters are declared as volatiles so that</span></span><br><span class="line"><span class="comment">     * ongoing actions are based on freshest values, but without need</span></span><br><span class="line"><span class="comment">     * for locking, since no internal invariants depend on them</span></span><br><span class="line"><span class="comment">     * changing synchronously with respect to other actions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Factory for new threads. All threads are created using this</span></span><br><span class="line"><span class="comment">     * factory (via method addWorker).  All callers must be prepared</span></span><br><span class="line"><span class="comment">     * for addWorker to fail, which may reflect a system or user&#x27;s</span></span><br><span class="line"><span class="comment">     * policy limiting the number of threads.  Even though it is not</span></span><br><span class="line"><span class="comment">     * treated as an error, failure to create threads may result in</span></span><br><span class="line"><span class="comment">     * new tasks being rejected or existing ones remaining stuck in</span></span><br><span class="line"><span class="comment">     * the queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We go further and preserve pool invariants even in the face of</span></span><br><span class="line"><span class="comment">     * errors such as OutOfMemoryError, that might be thrown while</span></span><br><span class="line"><span class="comment">     * trying to create threads.  Such errors are rather common due to</span></span><br><span class="line"><span class="comment">     * the need to allocate a native stack in Thread.start, and users</span></span><br><span class="line"><span class="comment">     * will want to perform clean pool shutdown to clean up.  There</span></span><br><span class="line"><span class="comment">     * will likely be enough memory available for the cleanup code to</span></span><br><span class="line"><span class="comment">     * complete without encountering yet another OutOfMemoryError.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handler called when saturated or shutdown in execute.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Timeout in nanoseconds for idle threads waiting for work.</span></span><br><span class="line"><span class="comment">     * Threads use this timeout when there are more than corePoolSize</span></span><br><span class="line"><span class="comment">     * present or if allowCoreThreadTimeOut. Otherwise they wait</span></span><br><span class="line"><span class="comment">     * forever for new work.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If false (default), core threads stay alive even when idle.</span></span><br><span class="line"><span class="comment">     * If true, core threads use keepAliveTime to time out waiting</span></span><br><span class="line"><span class="comment">     * for work.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Core pool size is the minimum number of workers to keep alive</span></span><br><span class="line"><span class="comment">     * (and not allow to time out etc) unless allowCoreThreadTimeOut</span></span><br><span class="line"><span class="comment">     * is set, in which case the minimum is zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maximum pool size. Note that the actual maximum is internally</span></span><br><span class="line"><span class="comment">     * bounded by CAPACITY.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default rejected execution handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">        <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Permission required for callers of shutdown and shutdownNow.</span></span><br><span class="line"><span class="comment">     * We additionally require (see checkShutdownAccess) that callers</span></span><br><span class="line"><span class="comment">     * have permission to actually interrupt threads in the worker set</span></span><br><span class="line"><span class="comment">     * (as governed by Thread.interrupt, which relies on</span></span><br><span class="line"><span class="comment">     * ThreadGroup.checkAccess, which in turn relies on</span></span><br><span class="line"><span class="comment">     * SecurityManager.checkAccess). Shutdowns are attempted only if</span></span><br><span class="line"><span class="comment">     * these checks pass.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * All actual invocations of Thread.interrupt (see</span></span><br><span class="line"><span class="comment">     * interruptIdleWorkers and interruptWorkers) ignore</span></span><br><span class="line"><span class="comment">     * SecurityExceptions, meaning that the attempted interrupts</span></span><br><span class="line"><span class="comment">     * silently fail. In the case of shutdown, they should not fail</span></span><br><span class="line"><span class="comment">     * unless the SecurityManager has inconsistent policies, sometimes</span></span><br><span class="line"><span class="comment">     * allowing access to a thread and sometimes not. In such cases,</span></span><br><span class="line"><span class="comment">     * failure to actually interrupt threads may disable or delay full</span></span><br><span class="line"><span class="comment">     * termination. Other uses of interruptIdleWorkers are advisory,</span></span><br><span class="line"><span class="comment">     * and failure to actually interrupt will merely delay response to</span></span><br><span class="line"><span class="comment">     * configuration changes so is not handled exceptionally.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission shutdownPerm =</span><br><span class="line">        <span class="keyword">new</span> RuntimePermission(<span class="string">&quot;modifyThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class Worker mainly maintains interrupt control state for</span></span><br><span class="line"><span class="comment">     * threads running tasks, along with other minor bookkeeping.</span></span><br><span class="line"><span class="comment">     * This class opportunistically extends AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="comment">     * to simplify acquiring and releasing a lock surrounding each</span></span><br><span class="line"><span class="comment">     * task execution.  This protects against interrupts that are</span></span><br><span class="line"><span class="comment">     * intended to wake up a worker thread waiting for a task from</span></span><br><span class="line"><span class="comment">     * instead interrupting a task being run.  We implement a simple</span></span><br><span class="line"><span class="comment">     * non-reentrant mutual exclusion lock rather than use</span></span><br><span class="line"><span class="comment">     * ReentrantLock because we do not want worker tasks to be able to</span></span><br><span class="line"><span class="comment">     * reacquire the lock when they invoke pool control methods like</span></span><br><span class="line"><span class="comment">     * setCorePoolSize.  Additionally, to suppress interrupts until</span></span><br><span class="line"><span class="comment">     * the thread actually starts running tasks, we initialize lock</span></span><br><span class="line"><span class="comment">     * state to a negative value, and clear it upon start (in</span></span><br><span class="line"><span class="comment">     * runWorker).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">         * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lock methods</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">        <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Methods for setting control state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transitions runState to given target, or leaves it alone if</span></span><br><span class="line"><span class="comment">     * already at least the given target.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetState the desired state, either SHUTDOWN or STOP</span></span><br><span class="line"><span class="comment">     *        (but not TIDYING or TERMINATED -- use tryTerminate for that)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, targetState) ||</span><br><span class="line">                ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transitions to TERMINATED state if either (SHUTDOWN and pool</span></span><br><span class="line"><span class="comment">     * and queue empty) or (STOP and pool empty).  If otherwise</span></span><br><span class="line"><span class="comment">     * eligible to terminate but workerCount is nonzero, interrupts an</span></span><br><span class="line"><span class="comment">     * idle worker to ensure that shutdown signals propagate. This</span></span><br><span class="line"><span class="comment">     * method must be called following any action that might make</span></span><br><span class="line"><span class="comment">     * termination possible -- reducing worker count or removing tasks</span></span><br><span class="line"><span class="comment">     * from the queue during shutdown. The method is non-private to</span></span><br><span class="line"><span class="comment">     * allow access from ScheduledThreadPoolExecutor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                runStateAtLeast(c, TIDYING) ||</span><br><span class="line">                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">                interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        terminated();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                        termination.signalAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Methods for controlling interrupts to worker threads.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If there is a security manager, makes sure caller has</span></span><br><span class="line"><span class="comment">     * permission to shut down threads in general (see shutdownPerm).</span></span><br><span class="line"><span class="comment">     * If this passes, additionally makes sure the caller is allowed</span></span><br><span class="line"><span class="comment">     * to interrupt each worker thread. This might not be true even if</span></span><br><span class="line"><span class="comment">     * first check passed, if the SecurityManager treats some threads</span></span><br><span class="line"><span class="comment">     * specially.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkShutdownAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkPermission(shutdownPerm);</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">                    security.checkAccess(w.thread);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Interrupts all threads, even if active. Ignores SecurityExceptions</span></span><br><span class="line"><span class="comment">     * (in which case some threads may remain uninterrupted).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">                w.interruptIfStarted();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Interrupts threads that might be waiting for tasks (as</span></span><br><span class="line"><span class="comment">     * indicated by not being locked) so they can check for</span></span><br><span class="line"><span class="comment">     * termination or configuration changes. Ignores</span></span><br><span class="line"><span class="comment">     * SecurityExceptions (in which case some threads may remain</span></span><br><span class="line"><span class="comment">     * uninterrupted).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyOne If true, interrupt at most one worker. This is</span></span><br><span class="line"><span class="comment">     * called only from tryTerminate when termination is otherwise</span></span><br><span class="line"><span class="comment">     * enabled but there are still other workers.  In this case, at</span></span><br><span class="line"><span class="comment">     * most one waiting worker is interrupted to propagate shutdown</span></span><br><span class="line"><span class="comment">     * signals in case all threads are currently waiting.</span></span><br><span class="line"><span class="comment">     * Interrupting any arbitrary thread ensures that newly arriving</span></span><br><span class="line"><span class="comment">     * workers since shutdown began will also eventually exit.</span></span><br><span class="line"><span class="comment">     * To guarantee eventual termination, it suffices to always</span></span><br><span class="line"><span class="comment">     * interrupt only one idle worker, but shutdown() interrupts all</span></span><br><span class="line"><span class="comment">     * idle workers so that redundant workers exit promptly, not</span></span><br><span class="line"><span class="comment">     * waiting for a straggler task to finish.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        w.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Common form of interruptIdleWorkers, to avoid having to</span></span><br><span class="line"><span class="comment">     * remember what the boolean argument means.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ONLY_ONE = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Misc utilities, most of which are also exported to</span></span><br><span class="line"><span class="comment">     * ScheduledThreadPoolExecutor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invokes the rejected execution handler for the given command.</span></span><br><span class="line"><span class="comment">     * Package-protected for use by ScheduledThreadPoolExecutor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs any further cleanup following run state transition on</span></span><br><span class="line"><span class="comment">     * invocation of shutdown.  A no-op here, but used by</span></span><br><span class="line"><span class="comment">     * ScheduledThreadPoolExecutor to cancel delayed tasks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * State check needed by ScheduledThreadPoolExecutor to</span></span><br><span class="line"><span class="comment">     * enable running tasks during shutdown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shutdownOK true if should return true if SHUTDOWN</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isRunningOrShutdown</span><span class="params">(<span class="keyword">boolean</span> shutdownOK)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">        <span class="keyword">return</span> rs == RUNNING || (rs == SHUTDOWN &amp;&amp; shutdownOK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Drains the task queue into a new list, normally using</span></span><br><span class="line"><span class="comment">     * drainTo. But if the queue is a DelayQueue or any other kind of</span></span><br><span class="line"><span class="comment">     * queue for which poll or drainTo may fail to remove some</span></span><br><span class="line"><span class="comment">     * elements, it deletes them one by one.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">        ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">        q.drainTo(taskList);</span><br><span class="line">        <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.remove(r))</span><br><span class="line">                    taskList.add(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> taskList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Methods for creating, running and cleaning up after workers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks if a new worker can be added with respect to current</span></span><br><span class="line"><span class="comment">     * pool state and the given bound (either core or maximum). If so,</span></span><br><span class="line"><span class="comment">     * the worker count is adjusted accordingly, and, if possible, a</span></span><br><span class="line"><span class="comment">     * new worker is created and started, running firstTask as its</span></span><br><span class="line"><span class="comment">     * first task. This method returns false if the pool is stopped or</span></span><br><span class="line"><span class="comment">     * eligible to shut down. It also returns false if the thread</span></span><br><span class="line"><span class="comment">     * factory fails to create a thread when asked.  If the thread</span></span><br><span class="line"><span class="comment">     * creation fails, either due to the thread factory returning</span></span><br><span class="line"><span class="comment">     * null, or due to an exception (typically OutOfMemoryError in</span></span><br><span class="line"><span class="comment">     * Thread.start()), we roll back cleanly.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the task the new thread should run first (or</span></span><br><span class="line"><span class="comment">     * null if none). Workers are created with an initial first task</span></span><br><span class="line"><span class="comment">     * (in method execute()) to bypass queuing when there are fewer</span></span><br><span class="line"><span class="comment">     * than corePoolSize threads (in which case we always start one),</span></span><br><span class="line"><span class="comment">     * or when the queue is full (in which case we must bypass queue).</span></span><br><span class="line"><span class="comment">     * Initially idle threads are usually created via</span></span><br><span class="line"><span class="comment">     * prestartCoreThread or to replace other dying workers.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment">     * maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment">     * value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment">     * state).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Rolls back the worker thread creation.</span></span><br><span class="line"><span class="comment">     * - removes worker from workers, if present</span></span><br><span class="line"><span class="comment">     * - decrements worker count</span></span><br><span class="line"><span class="comment">     * - rechecks for termination, in case the existence of this</span></span><br><span class="line"><span class="comment">     *   worker was holding up termination</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                workers.remove(w);</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            tryTerminate();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs cleanup and bookkeeping for a dying worker. Called</span></span><br><span class="line"><span class="comment">     * only from worker threads. Unless completedAbruptly is set,</span></span><br><span class="line"><span class="comment">     * assumes that workerCount has already been adjusted to account</span></span><br><span class="line"><span class="comment">     * for exit.  This method removes thread from worker set, and</span></span><br><span class="line"><span class="comment">     * possibly terminates the pool or replaces the worker if either</span></span><br><span class="line"><span class="comment">     * it exited due to user task exception or if fewer than</span></span><br><span class="line"><span class="comment">     * corePoolSize workers are running or queue is non-empty but</span></span><br><span class="line"><span class="comment">     * there are no workers.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> completedAbruptly if the worker died due to user exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completedTaskCount += w.completedTasks;</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tryTerminate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">                <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                    min = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">            &#125;</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs blocking or timed wait for a task, depending on</span></span><br><span class="line"><span class="comment">     * current configuration settings, or returns null if this worker</span></span><br><span class="line"><span class="comment">     * must exit because of any of:</span></span><br><span class="line"><span class="comment">     * 1. There are more than maximumPoolSize workers (due to</span></span><br><span class="line"><span class="comment">     *    a call to setMaximumPoolSize).</span></span><br><span class="line"><span class="comment">     * 2. The pool is stopped.</span></span><br><span class="line"><span class="comment">     * 3. The pool is shutdown and the queue is empty.</span></span><br><span class="line"><span class="comment">     * 4. This worker timed out waiting for a task, and timed-out</span></span><br><span class="line"><span class="comment">     *    workers are subject to termination (that is,</span></span><br><span class="line"><span class="comment">     *    &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span></span><br><span class="line"><span class="comment">     *    both before and after the timed wait, and if the queue is</span></span><br><span class="line"><span class="comment">     *    non-empty, this worker is not the last thread in the pool.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> task, or null if the worker must exit, in which case</span></span><br><span class="line"><span class="comment">     *         workerCount is decremented</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Main worker run loop.  Repeatedly gets tasks from queue and</span></span><br><span class="line"><span class="comment">     * executes them, while coping with a number of issues:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. We may start out with an initial task, in which case we</span></span><br><span class="line"><span class="comment">     * don&#x27;t need to get the first one. Otherwise, as long as pool is</span></span><br><span class="line"><span class="comment">     * running, we get tasks from getTask. If it returns null then the</span></span><br><span class="line"><span class="comment">     * worker exits due to changed pool state or configuration</span></span><br><span class="line"><span class="comment">     * parameters.  Other exits result from exception throws in</span></span><br><span class="line"><span class="comment">     * external code, in which case completedAbruptly holds, which</span></span><br><span class="line"><span class="comment">     * usually leads processWorkerExit to replace this thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. Before running any task, the lock is acquired to prevent</span></span><br><span class="line"><span class="comment">     * other pool interrupts while the task is executing, and then we</span></span><br><span class="line"><span class="comment">     * ensure that unless pool is stopping, this thread does not have</span></span><br><span class="line"><span class="comment">     * its interrupt set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. Each task run is preceded by a call to beforeExecute, which</span></span><br><span class="line"><span class="comment">     * might throw an exception, in which case we cause thread to die</span></span><br><span class="line"><span class="comment">     * (breaking loop with completedAbruptly true) without processing</span></span><br><span class="line"><span class="comment">     * the task.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 4. Assuming beforeExecute completes normally, we run the task,</span></span><br><span class="line"><span class="comment">     * gathering any of its thrown exceptions to send to afterExecute.</span></span><br><span class="line"><span class="comment">     * We separately handle RuntimeException, Error (both of which the</span></span><br><span class="line"><span class="comment">     * specs guarantee that we trap) and arbitrary Throwables.</span></span><br><span class="line"><span class="comment">     * Because we cannot rethrow Throwables within Runnable.run, we</span></span><br><span class="line"><span class="comment">     * wrap them within Errors on the way out (to the thread&#x27;s</span></span><br><span class="line"><span class="comment">     * UncaughtExceptionHandler).  Any thrown exception also</span></span><br><span class="line"><span class="comment">     * conservatively causes thread to die.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 5. After task.run completes, we call afterExecute, which may</span></span><br><span class="line"><span class="comment">     * also throw an exception, which will also cause thread to</span></span><br><span class="line"><span class="comment">     * die. According to JLS Sec 14.20, this exception is the one that</span></span><br><span class="line"><span class="comment">     * will be in effect even if task.run throws.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The net effect of the exception mechanics is that afterExecute</span></span><br><span class="line"><span class="comment">     * and the thread&#x27;s UncaughtExceptionHandler have as accurate</span></span><br><span class="line"><span class="comment">     * information as we can provide about any problems encountered by</span></span><br><span class="line"><span class="comment">     * user code.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Public constructors and methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment">     * parameters and default thread factory and rejected execution handler.</span></span><br><span class="line"><span class="comment">     * It may be more convenient to use one of the &#123;<span class="doctag">@link</span> Executors&#125; factory</span></span><br><span class="line"><span class="comment">     * methods instead of this general purpose constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">     *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment">     *        pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment">     *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment">     *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment">     *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment">     *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment">     * parameters and default rejected execution handler.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">     *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment">     *        pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment">     *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment">     *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment">     *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment">     *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment">     *        creates a new thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment">     *         or &#123;<span class="doctag">@code</span> threadFactory&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment">     * parameters and default thread factory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">     *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment">     *        pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment">     *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment">     *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment">     *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment">     *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment">     *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment">     *         or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment">     * parameters.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">     *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment">     *        pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment">     *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment">     *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment">     *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment">     *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment">     *        creates a new thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment">     *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment">     *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment">     * may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment">     * executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment">     * the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment">     *         cannot be accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initiates an orderly shutdown in which previously submitted</span></span><br><span class="line"><span class="comment">     * tasks are executed, but no new tasks will be accepted.</span></span><br><span class="line"><span class="comment">     * Invocation has no additional effect if already shut down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method does not wait for previously submitted tasks to</span></span><br><span class="line"><span class="comment">     * complete execution.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125;</span></span><br><span class="line"><span class="comment">     * to do that.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to stop all actively executing tasks, halts the</span></span><br><span class="line"><span class="comment">     * processing of waiting tasks, and returns a list of the tasks</span></span><br><span class="line"><span class="comment">     * that were awaiting execution. These tasks are drained (removed)</span></span><br><span class="line"><span class="comment">     * from the task queue upon return from this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method does not wait for actively executing tasks to</span></span><br><span class="line"><span class="comment">     * terminate.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125; to</span></span><br><span class="line"><span class="comment">     * do that.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span></span><br><span class="line"><span class="comment">     * processing actively executing tasks.  This implementation</span></span><br><span class="line"><span class="comment">     * cancels tasks via &#123;<span class="doctag">@link</span> Thread#interrupt&#125;, so any task that</span></span><br><span class="line"><span class="comment">     * fails to respond to interrupts may never terminate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Runnable&gt; tasks;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            advanceRunState(STOP);</span><br><span class="line">            interruptWorkers();</span><br><span class="line">            tasks = drainQueue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">        <span class="keyword">return</span> tasks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ! isRunning(ctl.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if this executor is in the process of terminating</span></span><br><span class="line"><span class="comment">     * after &#123;<span class="doctag">@link</span> #shutdown&#125; or &#123;<span class="doctag">@link</span> #shutdownNow&#125; but has not</span></span><br><span class="line"><span class="comment">     * completely terminated.  This method may be useful for</span></span><br><span class="line"><span class="comment">     * debugging. A return of &#123;<span class="doctag">@code</span> true&#125; reported a sufficient</span></span><br><span class="line"><span class="comment">     * period after shutdown may indicate that submitted tasks have</span></span><br><span class="line"><span class="comment">     * ignored or suppressed interruption, causing this executor not</span></span><br><span class="line"><span class="comment">     * to properly terminate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if terminating but not yet terminated</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">return</span> ! isRunning(c) &amp;&amp; runStateLessThan(c, TERMINATED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runStateAtLeast(ctl.get(), TERMINATED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                nanos = termination.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invokes &#123;<span class="doctag">@code</span> shutdown&#125; when this executor is no longer</span></span><br><span class="line"><span class="comment">     * referenced and it has no threads.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the thread factory used to create new threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory the new thread factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if threadFactory is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getThreadFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setThreadFactory</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the thread factory used to create new threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current thread factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setThreadFactory(ThreadFactory)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadFactory <span class="title">getThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets a new handler for unexecutable tasks.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler the new handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if handler is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getRejectedExecutionHandler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRejectedExecutionHandler</span><span class="params">(RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current handler for unexecutable tasks.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setRejectedExecutionHandler(RejectedExecutionHandler)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RejectedExecutionHandler <span class="title">getRejectedExecutionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the core number of threads.  This overrides any value set</span></span><br><span class="line"><span class="comment">     * in the constructor.  If the new value is smaller than the</span></span><br><span class="line"><span class="comment">     * current value, excess existing threads will be terminated when</span></span><br><span class="line"><span class="comment">     * they next become idle.  If larger, new threads will, if needed,</span></span><br><span class="line"><span class="comment">     * be started to execute any queued tasks.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize the new core size</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getCorePoolSize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">int</span> delta = corePoolSize - <span class="keyword">this</span>.corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// We don&#x27;t really know how many new threads are &quot;needed&quot;.</span></span><br><span class="line">            <span class="comment">// As a heuristic, prestart enough new workers (up to new</span></span><br><span class="line">            <span class="comment">// core size) to handle the current number of tasks in</span></span><br><span class="line">            <span class="comment">// queue, but stop if queue becomes empty while doing so.</span></span><br><span class="line">            <span class="keyword">int</span> k = Math.min(delta, workQueue.size());</span><br><span class="line">            <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (workQueue.isEmpty())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the core number of threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the core number of threads</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setCorePoolSize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCorePoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> corePoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Starts a core thread, causing it to idly wait for work. This</span></span><br><span class="line"><span class="comment">     * overrides the default policy of starting core threads only when</span></span><br><span class="line"><span class="comment">     * new tasks are executed. This method will return &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     * if all core threads have already been started.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if a thread was started</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prestartCoreThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> workerCountOf(ctl.get()) &lt; corePoolSize &amp;&amp;</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Same as prestartCoreThread except arranges that at least one</span></span><br><span class="line"><span class="comment">     * thread is started even if corePoolSize is 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(ctl.get());</span><br><span class="line">        <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Starts all core threads, causing them to idly wait for work. This</span></span><br><span class="line"><span class="comment">     * overrides the default policy of starting core threads only when</span></span><br><span class="line"><span class="comment">     * new tasks are executed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of threads started</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">            ++n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if this pool allows core threads to time out and</span></span><br><span class="line"><span class="comment">     * terminate if no tasks arrive within the keepAlive time, being</span></span><br><span class="line"><span class="comment">     * replaced if needed when new tasks arrive. When true, the same</span></span><br><span class="line"><span class="comment">     * keep-alive policy applying to non-core threads applies also to</span></span><br><span class="line"><span class="comment">     * core threads. When false (the default), core threads are never</span></span><br><span class="line"><span class="comment">     * terminated due to lack of incoming tasks.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if core threads are allowed to time out,</span></span><br><span class="line"><span class="comment">     *         else &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowsCoreThreadTimeOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> allowCoreThreadTimeOut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the policy governing whether core threads may time out and</span></span><br><span class="line"><span class="comment">     * terminate if no tasks arrive within the keep-alive time, being</span></span><br><span class="line"><span class="comment">     * replaced if needed when new tasks arrive. When false, core</span></span><br><span class="line"><span class="comment">     * threads are never terminated due to lack of incoming</span></span><br><span class="line"><span class="comment">     * tasks. When true, the same keep-alive policy applying to</span></span><br><span class="line"><span class="comment">     * non-core threads applies also to core threads. To avoid</span></span><br><span class="line"><span class="comment">     * continual thread replacement, the keep-alive time must be</span></span><br><span class="line"><span class="comment">     * greater than zero when setting &#123;<span class="doctag">@code</span> true&#125;. This method</span></span><br><span class="line"><span class="comment">     * should in general be called before the pool is actively used.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value &#123;<span class="doctag">@code</span> true&#125; if should time out, else &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if value is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     *         and the current keep-alive time is not greater than zero</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allowCoreThreadTimeOut</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Core threads must have nonzero keep alive times&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (value != allowCoreThreadTimeOut) &#123;</span><br><span class="line">            allowCoreThreadTimeOut = value;</span><br><span class="line">            <span class="keyword">if</span> (value)</span><br><span class="line">                interruptIdleWorkers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the maximum allowed number of threads. This overrides any</span></span><br><span class="line"><span class="comment">     * value set in the constructor. If the new value is smaller than</span></span><br><span class="line"><span class="comment">     * the current value, excess existing threads will be</span></span><br><span class="line"><span class="comment">     * terminated when they next become idle.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize the new maximum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the new maximum is</span></span><br><span class="line"><span class="comment">     *         less than or equal to zero, or</span></span><br><span class="line"><span class="comment">     *         less than the &#123;<span class="doctag">@linkplain</span> #getCorePoolSize core pool size&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getMaximumPoolSize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaximumPoolSize</span><span class="params">(<span class="keyword">int</span> maximumPoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the maximum allowed number of threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the maximum allowed number of threads</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setMaximumPoolSize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaximumPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maximumPoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the time limit for which threads may remain idle before</span></span><br><span class="line"><span class="comment">     * being terminated.  If there are more than the core number of</span></span><br><span class="line"><span class="comment">     * threads currently in the pool, after waiting this amount of</span></span><br><span class="line"><span class="comment">     * time without processing a task, excess threads will be</span></span><br><span class="line"><span class="comment">     * terminated.  This overrides any value set in the constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time the time to wait.  A time value of zero will cause</span></span><br><span class="line"><span class="comment">     *        excess threads to terminate immediately after executing tasks.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the &#123;<span class="doctag">@code</span> time&#125; argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> time&#125; less than zero or</span></span><br><span class="line"><span class="comment">     *         if &#123;<span class="doctag">@code</span> time&#125; is zero and &#123;<span class="doctag">@code</span> allowsCoreThreadTimeOut&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getKeepAliveTime(TimeUnit)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeepAliveTime</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (time == <span class="number">0</span> &amp;&amp; allowsCoreThreadTimeOut())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Core threads must have nonzero keep alive times&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = unit.toNanos(time);</span><br><span class="line">        <span class="keyword">long</span> delta = keepAliveTime - <span class="keyword">this</span>.keepAliveTime;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the thread keep-alive time, which is the amount of time</span></span><br><span class="line"><span class="comment">     * that threads in excess of the core pool size may remain</span></span><br><span class="line"><span class="comment">     * idle before being terminated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the desired time unit of the result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the time limit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setKeepAliveTime(long, TimeUnit)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getKeepAliveTime</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* User-level queue utilities */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the task queue used by this executor. Access to the</span></span><br><span class="line"><span class="comment">     * task queue is intended primarily for debugging and monitoring.</span></span><br><span class="line"><span class="comment">     * This queue may be in active use.  Retrieving the task queue</span></span><br><span class="line"><span class="comment">     * does not prevent queued tasks from executing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the task queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BlockingQueue&lt;Runnable&gt; <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> workQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes this task from the executor&#x27;s internal queue if it is</span></span><br><span class="line"><span class="comment">     * present, thus causing it not to be run if it has not already</span></span><br><span class="line"><span class="comment">     * started.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method may be useful as one part of a cancellation</span></span><br><span class="line"><span class="comment">     * scheme.  It may fail to remove tasks that have been converted</span></span><br><span class="line"><span class="comment">     * into other forms before being placed on the internal queue. For</span></span><br><span class="line"><span class="comment">     * example, a task entered using &#123;<span class="doctag">@code</span> submit&#125; might be</span></span><br><span class="line"><span class="comment">     * converted into a form that maintains &#123;<span class="doctag">@code</span> Future&#125; status.</span></span><br><span class="line"><span class="comment">     * However, in such cases, method &#123;<span class="doctag">@link</span> #purge&#125; may be used to</span></span><br><span class="line"><span class="comment">     * remove those Futures that have been cancelled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to remove</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the task was removed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> removed = workQueue.remove(task);</span><br><span class="line">        tryTerminate(); <span class="comment">// In case SHUTDOWN and now empty</span></span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tries to remove from the work queue all &#123;<span class="doctag">@link</span> Future&#125;</span></span><br><span class="line"><span class="comment">     * tasks that have been cancelled. This method can be useful as a</span></span><br><span class="line"><span class="comment">     * storage reclamation operation, that has no other impact on</span></span><br><span class="line"><span class="comment">     * functionality. Cancelled tasks are never executed, but may</span></span><br><span class="line"><span class="comment">     * accumulate in work queues until worker threads can actively</span></span><br><span class="line"><span class="comment">     * remove them. Invoking this method instead tries to remove them now.</span></span><br><span class="line"><span class="comment">     * However, this method may fail to remove tasks in</span></span><br><span class="line"><span class="comment">     * the presence of interference by other threads.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Iterator&lt;Runnable&gt; it = q.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                Runnable r = it.next();</span><br><span class="line">                <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;)r).isCancelled())</span><br><span class="line">                    it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConcurrentModificationException fallThrough) &#123;</span><br><span class="line">            <span class="comment">// Take slow path if we encounter interference during traversal.</span></span><br><span class="line">            <span class="comment">// Make copy for traversal and call remove for cancelled entries.</span></span><br><span class="line">            <span class="comment">// The slow path is more likely to be O(N*N).</span></span><br><span class="line">            <span class="keyword">for</span> (Object r : q.toArray())</span><br><span class="line">                <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;)r).isCancelled())</span><br><span class="line">                    q.remove(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tryTerminate(); <span class="comment">// In case SHUTDOWN and now empty</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Statistics */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current number of threads in the pool.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of threads</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Remove rare and surprising possibility of</span></span><br><span class="line">            <span class="comment">// isTerminated() &amp;&amp; getPoolSize() &gt; 0</span></span><br><span class="line">            <span class="keyword">return</span> runStateAtLeast(ctl.get(), TIDYING) ? <span class="number">0</span></span><br><span class="line">                : workers.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the approximate number of threads that are actively</span></span><br><span class="line"><span class="comment">     * executing tasks.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of threads</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">                <span class="keyword">if</span> (w.isLocked())</span><br><span class="line">                    ++n;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the largest number of threads that have ever</span></span><br><span class="line"><span class="comment">     * simultaneously been in the pool.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of threads</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLargestPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> largestPoolSize;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the approximate total number of tasks that have ever been</span></span><br><span class="line"><span class="comment">     * scheduled for execution. Because the states of tasks and</span></span><br><span class="line"><span class="comment">     * threads may change dynamically during computation, the returned</span></span><br><span class="line"><span class="comment">     * value is only an approximation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of tasks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> n = completedTaskCount;</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">                n += w.completedTasks;</span><br><span class="line">                <span class="keyword">if</span> (w.isLocked())</span><br><span class="line">                    ++n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n + workQueue.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the approximate total number of tasks that have</span></span><br><span class="line"><span class="comment">     * completed execution. Because the states of tasks and threads</span></span><br><span class="line"><span class="comment">     * may change dynamically during computation, the returned value</span></span><br><span class="line"><span class="comment">     * is only an approximation, but one that does not ever decrease</span></span><br><span class="line"><span class="comment">     * across successive calls.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of tasks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCompletedTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> n = completedTaskCount;</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">                n += w.completedTasks;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string identifying this pool, as well as its state,</span></span><br><span class="line"><span class="comment">     * including indications of run state and estimated worker and</span></span><br><span class="line"><span class="comment">     * task counts.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a string identifying this pool, as well as its state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ncompleted;</span><br><span class="line">        <span class="keyword">int</span> nworkers, nactive;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ncompleted = completedTaskCount;</span><br><span class="line">            nactive = <span class="number">0</span>;</span><br><span class="line">            nworkers = workers.size();</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">                ncompleted += w.completedTasks;</span><br><span class="line">                <span class="keyword">if</span> (w.isLocked())</span><br><span class="line">                    ++nactive;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        String rs = (runStateLessThan(c, SHUTDOWN) ? <span class="string">&quot;Running&quot;</span> :</span><br><span class="line">                     (runStateAtLeast(c, TERMINATED) ? <span class="string">&quot;Terminated&quot;</span> :</span><br><span class="line">                      <span class="string">&quot;Shutting down&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() +</span><br><span class="line">            <span class="string">&quot;[&quot;</span> + rs +</span><br><span class="line">            <span class="string">&quot;, pool size = &quot;</span> + nworkers +</span><br><span class="line">            <span class="string">&quot;, active threads = &quot;</span> + nactive +</span><br><span class="line">            <span class="string">&quot;, queued tasks = &quot;</span> + workQueue.size() +</span><br><span class="line">            <span class="string">&quot;, completed tasks = &quot;</span> + ncompleted +</span><br><span class="line">            <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extension hooks */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Method invoked prior to executing the given Runnable in the</span></span><br><span class="line"><span class="comment">     * given thread.  This method is invoked by thread &#123;<span class="doctag">@code</span> t&#125; that</span></span><br><span class="line"><span class="comment">     * will execute task &#123;<span class="doctag">@code</span> r&#125;, and may be used to re-initialize</span></span><br><span class="line"><span class="comment">     * ThreadLocals, or to perform logging.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation does nothing, but may be customized in</span></span><br><span class="line"><span class="comment">     * subclasses. Note: To properly nest multiple overridings, subclasses</span></span><br><span class="line"><span class="comment">     * should generally invoke &#123;<span class="doctag">@code</span> super.beforeExecute&#125; at the end of</span></span><br><span class="line"><span class="comment">     * this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the thread that will run task &#123;<span class="doctag">@code</span> r&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the task that will be executed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Method invoked upon completion of execution of the given Runnable.</span></span><br><span class="line"><span class="comment">     * This method is invoked by the thread that executed the task. If</span></span><br><span class="line"><span class="comment">     * non-null, the Throwable is the uncaught &#123;<span class="doctag">@code</span> RuntimeException&#125;</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> Error&#125; that caused execution to terminate abruptly.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation does nothing, but may be customized in</span></span><br><span class="line"><span class="comment">     * subclasses. Note: To properly nest multiple overridings, subclasses</span></span><br><span class="line"><span class="comment">     * should generally invoke &#123;<span class="doctag">@code</span> super.afterExecute&#125; at the</span></span><br><span class="line"><span class="comment">     * beginning of this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; When actions are enclosed in tasks (such as</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> FutureTask&#125;) either explicitly or via methods such as</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> submit&#125;, these task objects catch and maintain</span></span><br><span class="line"><span class="comment">     * computational exceptions, and so they do not cause abrupt</span></span><br><span class="line"><span class="comment">     * termination, and the internal exceptions are &lt;em&gt;not&lt;/em&gt;</span></span><br><span class="line"><span class="comment">     * passed to this method. If you would like to trap both kinds of</span></span><br><span class="line"><span class="comment">     * failures in this method, you can further probe for such cases,</span></span><br><span class="line"><span class="comment">     * as in this sample subclass that prints either the direct cause</span></span><br><span class="line"><span class="comment">     * or the underlying exception if a task has been aborted:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * class ExtendedExecutor extends ThreadPoolExecutor &#123;</span></span><br><span class="line"><span class="comment">     *   // ...</span></span><br><span class="line"><span class="comment">     *   protected void afterExecute(Runnable r, Throwable t) &#123;</span></span><br><span class="line"><span class="comment">     *     super.afterExecute(r, t);</span></span><br><span class="line"><span class="comment">     *     if (t == null &amp;&amp; r instanceof Future&lt;?&gt;) &#123;</span></span><br><span class="line"><span class="comment">     *       try &#123;</span></span><br><span class="line"><span class="comment">     *         Object result = ((Future&lt;?&gt;) r).get();</span></span><br><span class="line"><span class="comment">     *       &#125; catch (CancellationException ce) &#123;</span></span><br><span class="line"><span class="comment">     *           t = ce;</span></span><br><span class="line"><span class="comment">     *       &#125; catch (ExecutionException ee) &#123;</span></span><br><span class="line"><span class="comment">     *           t = ee.getCause();</span></span><br><span class="line"><span class="comment">     *       &#125; catch (InterruptedException ie) &#123;</span></span><br><span class="line"><span class="comment">     *           Thread.currentThread().interrupt(); // ignore/reset</span></span><br><span class="line"><span class="comment">     *       &#125;</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     *     if (t != null)</span></span><br><span class="line"><span class="comment">     *       System.out.println(t);</span></span><br><span class="line"><span class="comment">     *   &#125;</span></span><br><span class="line"><span class="comment">     * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable that has completed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the exception that caused termination, or null if</span></span><br><span class="line"><span class="comment">     * execution completed normally</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Method invoked when the Executor has terminated.  Default</span></span><br><span class="line"><span class="comment">     * implementation does nothing. Note: To properly nest multiple</span></span><br><span class="line"><span class="comment">     * overridings, subclasses should generally invoke</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> super.terminated&#125; within this method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Predefined RejectedExecutionHandlers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A handler for rejected tasks that runs the rejected task</span></span><br><span class="line"><span class="comment">     * directly in the calling thread of the &#123;<span class="doctag">@code</span> execute&#125; method,</span></span><br><span class="line"><span class="comment">     * unless the executor has been shut down, in which case the task</span></span><br><span class="line"><span class="comment">     * is discarded.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a &#123;<span class="doctag">@code</span> CallerRunsPolicy&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Executes task r in the caller&#x27;s thread, unless the executor</span></span><br><span class="line"><span class="comment">         * has been shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A handler for rejected tasks that throws a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> RejectedExecutionException&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates an &#123;<span class="doctag">@code</span> AbortPolicy&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Always throws RejectedExecutionException.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> RejectedExecutionException always</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                                 <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                                 e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A handler for rejected tasks that silently discards the</span></span><br><span class="line"><span class="comment">     * rejected task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a &#123;<span class="doctag">@code</span> DiscardPolicy&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Does nothing, which has the effect of discarding task r.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A handler for rejected tasks that discards the oldest unhandled</span></span><br><span class="line"><span class="comment">     * request and then retries &#123;<span class="doctag">@code</span> execute&#125;, unless the executor</span></span><br><span class="line"><span class="comment">     * is shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a &#123;<span class="doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Obtains and ignores the next task that the executor</span></span><br><span class="line"><span class="comment">         * would otherwise execute, if one is immediately available,</span></span><br><span class="line"><span class="comment">         * and then retries execution of task r, unless the executor</span></span><br><span class="line"><span class="comment">         * is shut down, in which case task r is instead discarded.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/java/">java</a>
                
                    <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
                
            </div>
        
    </section>
</article>

    </div>
  
</section>


      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='/images/head/photo2.jpeg' />

<div class='header'>万松</div>
<div class='content'>
<div class='desc'>生活点滴和知识分享</div>
</div>
</section>


  <section class='m_widget links'>
<div class='header'>友情链接</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://www.fxiaoke.com/">
            <div class='name'>fxiaoke</div>
        </a></li>
    
    </ul>
</div>
</section>


  <section class='m_widget categories'>
<div class='header'>所有分类</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/BPMN/"><div class='name'>BPMN</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/BPMN/Flow/"><div class='name'>Flow</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/linux/"><div class='name'>linux</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E6%97%A5%E5%B8%B8%E5%B7%A5%E5%85%B7/mac/"><div class='name'>mac</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E4%B9%A6%E6%9E%B6/"><div class='name'>书架</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/"><div class='name'>扩展知识</div><div class='badget'>7</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E6%8A%80%E6%9C%AF/"><div class='name'>技术</div><div class='badget'>28</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E6%96%B9%E6%A1%88/"><div class='name'>方案</div><div class='badget'>4</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E6%97%A5%E5%B8%B8%E5%B7%A5%E5%85%B7/"><div class='name'>日常工具</div><div class='badget'>3</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E7%94%9F%E6%B4%BB/"><div class='name'>生活</div><div class='badget'>5</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"><div class='name'>算法</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E8%89%BA%E6%9C%AF/"><div class='name'>艺术</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/"><div class='name'>语言</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/%E8%AF%BB%E4%B9%A6%E5%AD%A6%E4%B9%A0/"><div class='name'>读书学习</div><div class='badget'>5</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E8%AF%BB%E4%B9%A6%E5%AD%A6%E4%B9%A0/"><div class='name'>读书学习</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/%E6%8A%80%E6%9C%AF/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"><div class='name'>问题总结</div><div class='badget'>1</div></a></li>
    
    </ul>
    
</div>
</section>


  
<div class="m_widget tagcloud">
    <div class="header">标签云</div>
    <div class='content'>
        <a href="/tags/BPMN/" style="font-size: 14px; color: #808080">BPMN</a> <a href="/tags/CAP/" style="font-size: 15px; color: #6b6b6b">CAP</a> <a href="/tags/Flow/" style="font-size: 14px; color: #808080">Flow</a> <a href="/tags/GIS/" style="font-size: 14px; color: #808080">GIS</a> <a href="/tags/Protobuf/" style="font-size: 14px; color: #808080">Protobuf</a> <a href="/tags/alfred/" style="font-size: 14px; color: #808080">alfred</a> <a href="/tags/angularjs/" style="font-size: 17px; color: #404040">angularjs</a> <a href="/tags/ansible/" style="font-size: 14px; color: #808080">ansible</a> <a href="/tags/arm/" style="font-size: 14px; color: #808080">arm</a> <a href="/tags/book/" style="font-size: 15px; color: #6b6b6b">book</a> <a href="/tags/bug/" style="font-size: 14px; color: #808080">bug</a> <a href="/tags/django/" style="font-size: 14px; color: #808080">django</a> <a href="/tags/dubbo/" style="font-size: 14px; color: #808080">dubbo</a> <a href="/tags/fastcgi/" style="font-size: 14px; color: #808080">fastcgi</a> <a href="/tags/fastfs/" style="font-size: 14px; color: #808080">fastfs</a> <a href="/tags/git/" style="font-size: 14px; color: #808080">git</a> <a href="/tags/ionic/" style="font-size: 17px; color: #404040">ionic</a> <a href="/tags/java/" style="font-size: 20px; color: #000">java</a> <a href="/tags/jdk/" style="font-size: 14px; color: #808080">jdk</a> <a href="/tags/jdk8-java/" style="font-size: 15px; color: #6b6b6b">jdk8.java</a> <a href="/tags/jmeter/" style="font-size: 14px; color: #808080">jmeter</a> <a href="/tags/linux/" style="font-size: 14px; color: #808080">linux</a> <a href="/tags/linux%E5%91%BD%E4%BB%A4/" style="font-size: 14px; color: #808080">linux命令</a> <a href="/tags/mac/" style="font-size: 15px; color: #6b6b6b">mac</a> <a href="/tags/maven/" style="font-size: 14px; color: #808080">maven</a> <a href="/tags/mp3/" style="font-size: 14px; color: #808080">mp3</a> <a href="/tags/mysql/" style="font-size: 14px; color: #808080">mysql</a> <a href="/tags/nginx/" style="font-size: 14px; color: #808080">nginx</a> <a href="/tags/nocomment/" style="font-size: 14px; color: #808080">nocomment</a> <a href="/tags/poi/" style="font-size: 14px; color: #808080">poi</a> <a href="/tags/python/" style="font-size: 17px; color: #404040">python</a> <a href="/tags/redis/" style="font-size: 15px; color: #6b6b6b">redis</a> <a href="/tags/rpc/" style="font-size: 14px; color: #808080">rpc</a> <a href="/tags/rsa/" style="font-size: 14px; color: #808080">rsa</a> <a href="/tags/schedule/" style="font-size: 14px; color: #808080">schedule</a> <a href="/tags/workflow/" style="font-size: 14px; color: #808080">workflow</a> <a href="/tags/zookeeper/" style="font-size: 14px; color: #808080">zookeeper</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/" style="font-size: 14px; color: #808080">一致性算法</a> <a href="/tags/%E4%BA%BA%E7%94%9F/" style="font-size: 16px; color: #555">人生</a> <a href="/tags/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/" style="font-size: 14px; color: #808080">人生感悟</a> <a href="/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/" style="font-size: 14px; color: #808080">人脸识别</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/" style="font-size: 14px; color: #808080">代码仓库</a> <a href="/tags/%E5%81%A5%E5%BA%B7/" style="font-size: 14px; color: #808080">健康</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 18px; color: #2b2b2b">分布式</a> <a href="/tags/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/" style="font-size: 14px; color: #808080">加密解密</a> <a href="/tags/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/" style="font-size: 14px; color: #808080">压力测试</a> <a href="/tags/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/" style="font-size: 15px; color: #6b6b6b">图片处理</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 17px; color: #404040">多线程</a> <a href="/tags/%E5%AD%98%E5%82%A8/" style="font-size: 14px; color: #808080">存储</a> <a href="/tags/%E5%AE%9A%E6%97%B6/" style="font-size: 14px; color: #808080">定时</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 14px; color: #808080">工具</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 14px; color: #808080">并发</a> <a href="/tags/%E5%BE%90%E6%82%B2%E9%B8%BF/" style="font-size: 14px; color: #808080">徐悲鸿</a> <a href="/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" style="font-size: 14px; color: #808080">性能测试</a> <a href="/tags/%E6%84%9F%E6%82%9F/" style="font-size: 15px; color: #6b6b6b">感悟</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 14px; color: #808080">排序</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/" style="font-size: 15px; color: #6b6b6b">服务治理</a> <a href="/tags/%E6%9F%A5%E6%89%BE/" style="font-size: 14px; color: #808080">查找</a> <a href="/tags/%E6%B5%81%E7%A8%8B/" style="font-size: 14px; color: #808080">流程</a> <a href="/tags/%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E/" style="font-size: 14px; color: #808080">流程引擎</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 14px; color: #808080">测试</a> <a href="/tags/%E7%88%AC%E5%B1%B1/" style="font-size: 14px; color: #808080">爬山</a> <a href="/tags/%E7%96%91%E6%83%91/" style="font-size: 15px; color: #6b6b6b">疑惑</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 19px; color: #151515">算法</a> <a href="/tags/%E7%BB%8F%E9%AA%8C/" style="font-size: 14px; color: #808080">经验</a> <a href="/tags/%E7%BB%98%E7%94%BB/" style="font-size: 14px; color: #808080">绘画</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 15px; color: #6b6b6b">缓存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 17px; color: #404040">设计模式</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 14px; color: #808080">软件</a> <a href="/tags/%E8%BF%90%E5%8A%A8/" style="font-size: 14px; color: #808080">运动</a> <a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 15px; color: #6b6b6b">运维</a> <a href="/tags/%E9%9F%B3%E4%B9%90/" style="font-size: 14px; color: #808080">音乐</a> <a href="/tags/%E9%9F%B3%E9%A2%91%E8%BD%AC%E6%8D%A2/" style="font-size: 14px; color: #808080">音频转换</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/AaronWan" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
</footer>

  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>

<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
</body>
</html>
